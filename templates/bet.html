<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Football Betting Analysis</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .main-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            margin: 20px auto;
            padding: 30px;
            max-width: 1400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .table-responsive {
            overflow-x: auto;
        }
        
        .table {
            font-size: 0.9rem;
        }
        
        .status-badge {
            font-size: 0.8rem;
            border-radius: 20px;
            padding: 5px 12px;
        }
        
        .status-scheduled {
            background-color: #ffc107;
            color: #000;
        }
        
        .status-in_progress {
            background-color: #0d6efd;
            color: white;
        }
        
        .status-finished {
            background-color: #198754;
            color: white;
        }
        
        .final-score-win {
            background-color: #28a745;
            color: white;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .final-score-loss {
            background-color: #dc3545;
            color: white;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .final-score-draw {
            background-color: #ffc107;
            color: #000;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .fav-team {
            font-weight: bold;
            color: #0d6efd;
        }
        
        .odds {
            font-weight: bold;
            color: #198754;
        }
        
        h1 {
            color: #1e3c72;
            margin-bottom: 30px;
        }
        
        .stats-col {
            white-space: pre-wrap;
            font-size: 0.85rem;
            max-width: 300px;
        }
        
        .api-limits-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .api-limits-card h5 {
            color: white;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .limits-row {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .limit-item {
            text-align: center;
            flex: 1;
            min-width: 150px;
        }
        
        .limit-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .limit-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .limit-warning {
            color: #ffc107;
        }
        
        .limit-critical {
            color: #dc3545;
        }
        
        .limit-ok {
            color: #28a745;
        }
        
        .sortable-header {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px !important;
        }
        
        .sortable-header:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .sortable-header::after {
            content: '↕';
            position: absolute;
            right: 5px;
            opacity: 0.3;
            font-size: 0.8em;
        }
        
        .sortable-header.sort-asc::after {
            content: '↑';
            opacity: 1;
            color: #0d6efd;
        }
        
        .sortable-header.sort-desc::after {
            content: '↓';
            opacity: 1;
            color: #0d6efd;
        }
        
        .stats-tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        
                 .stats-tooltip .tooltip-content {
             visibility: hidden;
             position: fixed;
             background-color: #333;
             color: white;
             text-align: left;
             border-radius: 8px;
             padding: 12px;
             font-size: 0.85rem;
             white-space: pre-line;
             z-index: 10000;
             min-width: 300px;
             max-width: 500px;
             box-shadow: 0 4px 6px rgba(0,0,0,0.3);
             opacity: 0;
             transition: opacity 0.3s;
             pointer-events: none;
         }
         
         .stats-tooltip:hover .tooltip-content {
             visibility: visible;
             opacity: 1;
         }
         
         .stats-tooltip .tooltip-content::after {
             content: "";
             position: absolute;
             top: 100%;
             left: 50%;
             transform: translateX(-50%);
             border-width: 5px;
             border-style: solid;
             border-color: #333 transparent transparent transparent;
         }
         
         .stats-tooltip.tooltip-bottom .tooltip-content::after {
             top: auto;
             bottom: 100%;
             border-color: transparent transparent #333 transparent;
         }
         
         .table-responsive {
             overflow-x: auto;
             overflow-y: visible;
         }
        
        .info-icon {
            color: #17a2b8;
            cursor: help;
        }
        
        /* Стили для красной буквы "ai" в заголовке */
        .ai-logo-a {
            color: #b23c17;
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1><i class="fas fa-futbol"></i> Футбольная <span class="ai-logo-a">ai</span>налитика</h1>
            {% if admin %}
            <div>
                <button class="btn btn-primary" id="sync-button" onclick="syncAndLoad()">
                    <i class="fas fa-sync-alt" id="sync-icon"></i> <span id="sync-text">Обновить</span>
                </button>
                <div class="spinner-border spinner-border-sm text-primary ms-2" id="sync-spinner" role="status" style="display: none;">
                    <span class="visually-hidden">Синхронизация...</span>
                </div>
            </div>
            {% endif %}
        </div>
        
        {% if admin %}
        <!-- Блок лимитов API -->
        <div class="api-limits-card" id="api-limits-card">
            <h5><i class="fas fa-chart-line"></i> Лимиты API The Odds API</h5>
            <div class="limits-row" id="limits-row">
                <div class="limit-item">
                    <div class="limit-value" id="limit-remaining">-</div>
                    <div class="limit-label">Осталось запросов</div>
                </div>
                <div class="limit-item">
                    <div class="limit-value" id="limit-used">-</div>
                    <div class="limit-label">Использовано</div>
                </div>
                <div class="limit-item">
                    <div class="limit-value" id="limit-cost">-</div>
                    <div class="limit-label">Стоимость последнего</div>
                </div>
            </div>
        </div>
        {% endif %}
        
        <div id="loading" class="text-center my-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Загрузка...</span>
            </div>
        </div>
        
        <div id="matches-container" style="display: none;">
            <div class="table-responsive">
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th class="sortable-header" data-sort="match_date">Дата</th>
                            <th class="sortable-header" data-sort="match_time">Время</th>
                            <th class="sortable-header" data-sort="home_team">Хозяева</th>
                            <th class="sortable-header" data-sort="away_team">Гости</th>
                            <th class="sortable-header" data-sort="fav">Фаворит</th>
                            <th class="sortable-header" data-sort="initial_odds">K0</th>
                            <th class="sortable-header" data-sort="last_odds">K1</th>
                            <th class="sortable-header" data-sort="live_odds">K60</th>
                            <th class="sortable-header" data-sort="bet">Bet</th>
                            <th class="sortable-header" data-sort="bet_ai">Прогноз ИИ</th>
                            <th class="sortable-header" data-sort="final_score">Итоговый счёт</th>
                            <th class="sortable-header" data-sort="status">Статус</th>
                        </tr>
                    </thead>
                    <tbody id="matches-table-body">
                    </tbody>
                    <tfoot id="totals-row" style="display: none;">
                        <tr style="background-color: #f8f9fa; font-weight: bold;">
                            <td colspan="5" style="text-align: right;">Итого:</td>
                            <td id="total-k0" class="odds">-</td>
                            <td id="total-k1" class="odds">-</td>
                            <td id="total-k60" class="odds">-</td>
                            <td id="total-bet" class="odds">-</td>
                            <td id="total-bet-ai" class="odds">-</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </tfoot>
                </table>
            </div>
            <div id="empty-state" class="text-center my-5" style="display: none;">
                <i class="fas fa-futbol fa-3x text-muted mb-3"></i>
                <p class="text-muted">Нет матчей для отображения</p>
            </div>
        </div>
    </div>

    <script>
        // Глобальная переменная для хранения данных матчей
        let allMatches = [];
        let currentSortField = null;
        let currentSortDirection = 'asc';

        // Инициализация обработчиков сортировки
        document.addEventListener('DOMContentLoaded', function() {
            const headers = document.querySelectorAll('.sortable-header');
            headers.forEach(header => {
                header.addEventListener('click', function() {
                    const sortField = this.getAttribute('data-sort');
                    sortTable(sortField);
                });
            });
        });

        function sortTable(field) {
            if (!allMatches || allMatches.length === 0) {
                return;
            }

            // Если кликнули по тому же полю - меняем направление, иначе сортируем по возрастанию
            if (currentSortField === field) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortField = field;
                currentSortDirection = 'asc';
            }

            // Сбрасываем классы сортировки со всех заголовков
            document.querySelectorAll('.sortable-header').forEach(h => {
                h.classList.remove('sort-asc', 'sort-desc');
            });

            // Добавляем класс к текущему заголовку
            const currentHeader = document.querySelector(`.sortable-header[data-sort="${field}"]`);
            if (currentHeader) {
                currentHeader.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
            }

            // Сортируем массив
            const sortedMatches = [...allMatches].sort((a, b) => {
                let valueA = a[field];
                let valueB = b[field];

                // Специальная обработка для разных типов полей
                if (field === 'final_score') {
                    // Для итогового счета - сравниваем сумму голов
                    const scoreA = (a.final_score_home || 0) + (a.final_score_away || 0);
                    const scoreB = (b.final_score_home || 0) + (b.final_score_away || 0);
                    valueA = scoreA;
                    valueB = scoreB;
                } else if (field === 'match_date' || field === 'match_time') {
                    // Для даты и времени - создаем полную дату для сравнения
                    const dateTimeA = new Date(`${a.match_date}T${a.match_time || '00:00'}`);
                    const dateTimeB = new Date(`${b.match_date}T${b.match_time || '00:00'}`);
                    valueA = dateTimeA.getTime();
                    valueB = dateTimeB.getTime();
                } else if (field === 'initial_odds' || field === 'last_odds' || field === 'live_odds' || field === 'bet') {
                    // Для коэффициентов - преобразуем в числа
                    valueA = parseFloat(valueA) || 0;
                    valueB = parseFloat(valueB) || 0;
                } else if (field === 'status') {
                    // Для статуса - используем порядок: scheduled < in_progress < finished
                    const statusOrder = {'scheduled': 1, 'in_progress': 2, 'finished': 3};
                    valueA = statusOrder[valueA] || 999;
                    valueB = statusOrder[valueB] || 999;
                }

                // Обработка null/undefined
                if (valueA == null) valueA = '';
                if (valueB == null) valueB = '';

                // Сравнение
                if (valueA < valueB) {
                    return currentSortDirection === 'asc' ? -1 : 1;
                } else if (valueA > valueB) {
                    return currentSortDirection === 'asc' ? 1 : -1;
                }
                return 0;
            });

            // Обновляем отображение
            displayMatches(sortedMatches);
        }

        function syncAndLoad() {
            const syncButton = document.getElementById('sync-button');
            const syncIcon = document.getElementById('sync-icon');
            const syncText = document.getElementById('sync-text');
            const syncSpinner = document.getElementById('sync-spinner');
            
            // Блокируем кнопку и показываем спиннер
            syncButton.disabled = true;
            syncIcon.style.display = 'none';
            syncText.textContent = 'Синхронизация...';
            syncSpinner.style.display = 'inline-block';
            
            // Запускаем синхронизацию
            fetch('/api/football/sync', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Синхронизация завершена:', data.stats);
                    // После синхронизации запускаем проверку матчей
                    syncText.textContent = 'Проверка матчей...';
                    return fetch('/api/football/check', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                } else {
                    console.error('Ошибка синхронизации:', data.error);
                    alert('Ошибка синхронизации: ' + (data.error || 'Неизвестная ошибка'));
                    throw new Error('Синхронизация не удалась');
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Проверка матчей завершена');
                    // После успешной проверки загружаем обновленные данные
                    loadMatches();
                    if (isAdmin) {
                        loadLimits();
                    }
                } else {
                    console.error('Ошибка проверки матчей:', data.error);
                    alert('Ошибка проверки матчей: ' + (data.error || 'Неизвестная ошибка'));
                    // Всё равно обновляем данные
                    loadMatches();
                    if (isAdmin) {
                        loadLimits();
                    }
                }
            })
            .catch(error => {
                console.error('Ошибка запроса:', error);
                alert('Ошибка: ' + error.message);
                // Всё равно обновляем данные
                loadMatches();
                if (isAdmin) {
                    loadLimits();
                }
            })
            .finally(() => {
                // Восстанавливаем кнопку
                syncButton.disabled = false;
                syncIcon.style.display = 'inline';
                syncText.textContent = 'Обновить';
                syncSpinner.style.display = 'none';
            });
        }
        
        function loadLimits() {
            fetch('/api/football/limits')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.limits) {
                        const limits = data.limits;
                        
                        // Осталось запросов
                        const remainingEl = document.getElementById('limit-remaining');
                        if (limits.requests_remaining !== null && limits.requests_remaining !== undefined) {
                            remainingEl.textContent = limits.requests_remaining;
                            
                            // Цвет в зависимости от количества
                            remainingEl.className = 'limit-value';
                            if (limits.requests_remaining < 50) {
                                remainingEl.classList.add('limit-critical');
                            } else if (limits.requests_remaining < 100) {
                                remainingEl.classList.add('limit-warning');
                            } else {
                                remainingEl.classList.add('limit-ok');
                            }
                        } else {
                            remainingEl.textContent = 'N/A';
                            remainingEl.className = 'limit-value';
                        }
                        
                        // Использовано
                        const usedEl = document.getElementById('limit-used');
                        if (limits.requests_used !== null && limits.requests_used !== undefined) {
                            usedEl.textContent = limits.requests_used;
                            usedEl.className = 'limit-value';
                        } else {
                            usedEl.textContent = 'N/A';
                            usedEl.className = 'limit-value';
                        }
                        
                        // Стоимость последнего запроса
                        const costEl = document.getElementById('limit-cost');
                        if (limits.requests_last_cost !== null && limits.requests_last_cost !== undefined) {
                            costEl.textContent = limits.requests_last_cost;
                            costEl.className = 'limit-value';
                        } else {
                            costEl.textContent = 'N/A';
                            costEl.className = 'limit-value';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading API limits:', error);
                    document.getElementById('limit-remaining').textContent = 'Ошибка';
                    document.getElementById('limit-used').textContent = 'Ошибка';
                    document.getElementById('limit-cost').textContent = 'Ошибка';
                });
        }
        
        function loadMatches() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('matches-container').style.display = 'none';
            
            fetch('/api/football/matches')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('loading').style.display = 'none';
                    
                    if (data.success && data.matches && data.matches.length > 0) {
                        // Сохраняем данные в глобальную переменную
                        allMatches = data.matches;
                        
                        document.getElementById('matches-container').style.display = 'block';
                        document.getElementById('empty-state').style.display = 'none';
                        
                        // Сортировка по умолчанию: дата и время (по убыванию - новые матчи сверху)
                        if (!currentSortField) {
                            currentSortField = 'match_date';
                            currentSortDirection = 'desc';
                        }
                        sortTable(currentSortField);
                    } else {
                        allMatches = [];
                        document.getElementById('empty-state').style.display = 'block';
                    }
                })
                .catch(error => {
                    console.error('Error loading matches:', error);
                    document.getElementById('loading').style.display = 'none';
                    allMatches = [];
                    document.getElementById('empty-state').style.display = 'block';
                });
        }

                 function calculateTotals(matches) {
             let sumK0 = 0;
             let sumK1 = 0;
             let sumK60 = 0;
             let sumBet = 0;
             let sumBetAI = 0;
             
             matches.forEach(match => {
                 // Пропускаем незавершенные матчи
                 if (match.status !== 'finished') {
                     return;
                 }
                 
                 // Если фаворит выиграл (fav_won === 1): прибыль = коэффициент - 1 (получаем коэффициент, но вложили 1)
                 // Если проиграл или ничья (fav_won !== 1): прибыль = -1 (теряем ставку)
                 // Считаем только если есть коэффициент (ставка была сделана)
                 
                 // K0 - ставка на фаворита после открытия линии (initial_odds)
                 if (match.initial_odds && !isNaN(parseFloat(match.initial_odds))) {
                     if (match.fav_won === 1) {
                         sumK0 += parseFloat(match.initial_odds) - 1;
                     } else {
                         sumK0 -= 1;
                     }
                 }
                 
                 // K1 - ставка на фаворита в день матча (last_odds)
                 if (match.last_odds && !isNaN(parseFloat(match.last_odds))) {
                     if (match.fav_won === 1) {
                         sumK1 += parseFloat(match.last_odds) - 1;
                     } else {
                         sumK1 -= 1;
                     }
                 }
                 
                 // K60 - ставка на фаворита в перерыве (live_odds)
                 if (match.live_odds && !isNaN(parseFloat(match.live_odds))) {
                     if (match.fav_won === 1) {
                         sumK60 += parseFloat(match.live_odds) - 1;
                     } else {
                         sumK60 -= 1;
                     }
                 }
                 
                 // Bet - ставка на фаворита в перерыве только если рекомендовано ИИ (bet >= 1), используем K60 (live_odds)
                 const betValue = match.bet ? parseFloat(match.bet) : 0;
                 if (betValue >= 1 && match.live_odds && !isNaN(parseFloat(match.live_odds))) {
                     if (match.fav_won === 1) {
                         // Фаворит выиграл - добавляем чистую прибыль от live_odds
                         sumBet += parseFloat(match.live_odds) - 1;
                     } else {
                         // Фаворит проиграл или ничья - вычитаем ставку (1)
                         sumBet -= 1;
                     }
                 }
                 
                 // Прогноз ИИ - ставка на прогнозированный исход ИИ (bet_ai_odds)
                 if (match.bet_ai && match.bet_ai_odds && !isNaN(parseFloat(match.bet_ai_odds))) {
                     // Определяем фактический результат матча
                     const homeScore = match.final_score_home !== null && match.final_score_home !== undefined ? parseInt(match.final_score_home) : null;
                     const awayScore = match.final_score_away !== null && match.final_score_away !== undefined ? parseInt(match.final_score_away) : null;
                     
                     if (homeScore !== null && awayScore !== null) {
                         let actualResult = null;
                         if (homeScore > awayScore) {
                             actualResult = '1';
                         } else if (homeScore === awayScore) {
                             actualResult = 'X';
                         } else {
                             actualResult = '2';
                         }
                         
                         // Проверяем, совпал ли прогноз ИИ с фактическим результатом
                         const betAIUpper = match.bet_ai.toUpperCase();
                         let isWin = false;
                         
                         if (betAIUpper === actualResult) {
                             // Одиночный исход совпал
                             isWin = true;
                         } else if (betAIUpper === '1X' && (actualResult === '1' || actualResult === 'X')) {
                             // Двойной шанс 1X выиграл
                             isWin = true;
                         } else if (betAIUpper === 'X2' && (actualResult === 'X' || actualResult === '2')) {
                             // Двойной шанс X2 выиграл
                             isWin = true;
                         }
                         
                         if (isWin) {
                             // Прогноз ИИ совпал - добавляем чистую прибыль
                             sumBetAI += parseFloat(match.bet_ai_odds) - 1;
                         } else {
                             // Прогноз ИИ не совпал - вычитаем ставку (1)
                             sumBetAI -= 1;
                         }
                     }
                 }
             });
             
            // Обновляем строку итогов
            const totalsRow = document.getElementById('totals-row');
            const totalK0El = document.getElementById('total-k0');
            const totalK1El = document.getElementById('total-k1');
            const totalK60El = document.getElementById('total-k60');
            const totalBetEl = document.getElementById('total-bet');
            const totalBetAIEl = document.getElementById('total-bet-ai');
            
            if (totalsRow && totalK0El && totalK1El && totalK60El && totalBetEl && totalBetAIEl) {
                totalK0El.textContent = sumK0.toFixed(2);
                totalK1El.textContent = sumK1.toFixed(2);
                totalK60El.textContent = sumK60.toFixed(2);
                totalBetEl.textContent = sumBet.toFixed(2);
                totalBetAIEl.textContent = sumBetAI.toFixed(2);
                
                // Показываем строку итогов только если есть завершенные матчи
                const finishedMatches = matches.filter(m => m.status === 'finished');
                if (finishedMatches.length > 0) {
                    totalsRow.style.display = '';
                } else {
                    totalsRow.style.display = 'none';
                }
            }
        }

        function extractStatValue(stats, statGroupName, statItemName) {
            // Функция для извлечения значения из элемента статистики
            const getValue = (item) => {
                // Используем homeValue/awayValue если они есть (числовые значения)
                if (item.homeValue !== undefined && item.awayValue !== undefined) {
                    return {
                        home: item.homeValue,
                        away: item.awayValue
                    };
                }
                // Иначе пытаемся парсить из строк home/away (могут быть "70%" или "10")
                const parseValue = (str) => {
                    if (!str) return 0;
                    const num = parseFloat(str.toString().replace('%', '').trim());
                    return isNaN(num) ? 0 : num;
                };
                return {
                    home: parseValue(item.home),
                    away: parseValue(item.away)
                };
            };
            
            // Пытаемся найти в raw_data.statistics (приоритет - там данные для периода "ALL")
            if (stats.raw_data && stats.raw_data.statistics && Array.isArray(stats.raw_data.statistics)) {
                for (const statPeriod of stats.raw_data.statistics) {
                    // Ищем период "ALL" (общая статистика матча)
                    if (statPeriod.period === 'ALL' && statPeriod.groups && Array.isArray(statPeriod.groups)) {
                        for (const group of statPeriod.groups) {
                            if (group.groupName === statGroupName && group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                for (const item of group.statisticsItems) {
                                    if (item.name === statItemName) {
                                        return getValue(item);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Пытаемся найти в statistics (верхний уровень)
            if (stats.statistics && Array.isArray(stats.statistics)) {
                for (const statPeriod of stats.statistics) {
                    if (statPeriod.period === 'ALL' && statPeriod.groups && Array.isArray(statPeriod.groups)) {
                        for (const group of statPeriod.groups) {
                            if (group.groupName === statGroupName && group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                for (const item of group.statisticsItems) {
                                    if (item.name === statItemName) {
                                        return getValue(item);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Пытаемся найти в periods (старый формат)
            if (stats.periods && Array.isArray(stats.periods)) {
                for (const period of stats.periods) {
                    if ((period.period === 'all' || period.period === 'REGULAR' || period.period === 'ALL') && period.groups && Array.isArray(period.groups)) {
                        for (const group of period.groups) {
                            if (group.groupName === statGroupName && group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                for (const item of group.statisticsItems) {
                                    if (item.name === statItemName) {
                                        return getValue(item);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Пытаемся найти в raw_data.periods (старый формат)
            if (stats.raw_data && stats.raw_data.periods && Array.isArray(stats.raw_data.periods)) {
                for (const period of stats.raw_data.periods) {
                    if ((period.period === 'all' || period.period === 'REGULAR' || period.period === 'ALL') && period.groups && Array.isArray(period.groups)) {
                        for (const group of period.groups) {
                            if (group.groupName === statGroupName && group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                for (const item of group.statisticsItems) {
                                    if (item.name === statItemName) {
                                        return getValue(item);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return null;
        }
        
        function formatStats(statsJson) {
            if (!statsJson) return null;
            
            try {
                const stats = typeof statsJson === 'string' ? JSON.parse(statsJson) : statsJson;
                if (!stats || typeof stats !== 'object') return null;
                
                let formatted = [];
                
                // Счет
                if (stats.score) {
                    formatted.push(`Счет: ${stats.score.home || 0} - ${stats.score.away || 0}`);
                }
                
                // Владение мячом - в группе "Match overview"
                let possession = extractStatValue(stats, 'Match overview', 'Ball possession');
                if (possession) {
                    formatted.push(`Владение: ${possession.home || 0}% - ${possession.away || 0}%`);
                }
                
                // Удары в створ - в группе "Shots"
                let shotsOnTarget = extractStatValue(stats, 'Shots', 'Shots on target');
                if (shotsOnTarget) {
                    formatted.push(`Удары в створ: ${shotsOnTarget.home || 0} - ${shotsOnTarget.away || 0}`);
                }
                
                // xG - в группе "Match overview"
                let xg = extractStatValue(stats, 'Match overview', 'Expected goals');
                if (xg) {
                    formatted.push(`xG: ${(xg.home || 0).toFixed(2)} - ${(xg.away || 0).toFixed(2)}`);
                }
                
                // Общие удары - в группе "Shots" или "Match overview"
                let shots = extractStatValue(stats, 'Shots', 'Total shots');
                if (!shots) {
                    shots = extractStatValue(stats, 'Match overview', 'Total shots');
                }
                if (shots) {
                    formatted.push(`Всего ударов: ${shots.home || 0} - ${shots.away || 0}`);
                }
                
                // Угловые - в группе "Match overview"
                let corners = extractStatValue(stats, 'Match overview', 'Corner kicks');
                if (corners) {
                    formatted.push(`Угловые: ${corners.home || 0} - ${corners.away || 0}`);
                }
                
                // Желтые карточки - в группе "Match overview"
                let yellowCards = extractStatValue(stats, 'Match overview', 'Yellow cards');
                if (yellowCards) {
                    formatted.push(`Желтые карточки: ${yellowCards.home || 0} - ${yellowCards.away || 0}`);
                }
                
                // Фолы - в группе "Match overview"
                let fouls = extractStatValue(stats, 'Match overview', 'Fouls');
                if (fouls) {
                    formatted.push(`Фолы: ${fouls.home || 0} - ${fouls.away || 0}`);
                }
                
                // Если ничего не нашлось, показываем структуру для отладки
                if (formatted.length === 1 && formatted[0].startsWith('Счет:')) {
                    console.warn('Найдена только статистика счета. Структура данных:', stats);
                    // Пробуем показать все доступные группы статистики
                    let debugInfo = ['=== Отладка структуры ==='];
                    if (stats.periods && Array.isArray(stats.periods)) {
                        stats.periods.forEach((period, idx) => {
                            if (period.groups && Array.isArray(period.groups)) {
                                period.groups.forEach(group => {
                                    debugInfo.push(`Период ${idx}, Группа: ${group.groupName || 'N/A'}`);
                                    if (group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                        group.statisticsItems.forEach(item => {
                                            debugInfo.push(`  - ${item.name || 'N/A'}: ${item.home || 0} - ${item.away || 0}`);
                                        });
                                    }
                                });
                            }
                        });
                    }
                    if (stats.statistics && Array.isArray(stats.statistics)) {
                        stats.statistics.forEach(group => {
                            debugInfo.push(`Группа: ${group.groupName || 'N/A'}`);
                            if (group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                group.statisticsItems.forEach(item => {
                                    debugInfo.push(`  - ${item.name || 'N/A'}: ${item.home || 0} - ${item.away || 0}`);
                                });
                            }
                        });
                    }
                    console.log(debugInfo.join('\n'));
                    
                    // Добавляем упрощенную структуру в tooltip
                    if (debugInfo.length > 1) {
                        formatted.push('\n' + debugInfo.slice(1).join('\n'));
                    }
                }
                
                return formatted.length > 0 ? formatted.join('\n') : null;
            } catch (e) {
                console.error('Ошибка парсинга статистики:', e);
                console.error('Данные статистики:', statsJson);
                return null;
            }
        }
        
        function displayMatches(matches) {
            const tbody = document.getElementById('matches-table-body');
            tbody.innerHTML = '';
            
            matches.forEach(match => {
                const row = document.createElement('tr');
                
                const statusBadgeClass = `status-${match.status}`;
                const statusText = {
                    'scheduled': 'Запланирован',
                    'in_progress': 'Идет',
                    'finished': 'Завершен'
                }[match.status] || match.status;
                
                const finalScore = match.final_score_home !== null && match.final_score_away !== null
                    ? `${match.final_score_home}-${match.final_score_away}`
                    : '-';
                
                // Определяем класс для подсветки итогового счета в зависимости от результата фаворита
                let finalScoreHtml = finalScore;
                if (match.status === 'finished' && match.final_score_home !== null && match.final_score_away !== null) {
                    const homeScore = parseInt(match.final_score_home);
                    const awayScore = parseInt(match.final_score_away);
                    const isDraw = homeScore === awayScore;
                    
                    let finalScoreClass = '';
                    if (isDraw) {
                        // Ничья - желтый
                        finalScoreClass = 'final-score-draw';
                    } else if (match.fav_won === 1) {
                        // Фаворит выиграл - зеленый
                        finalScoreClass = 'final-score-win';
                    } else {
                        // Фаворит проиграл - красный
                        finalScoreClass = 'final-score-loss';
                    }
                    
                    if (finalScoreClass) {
                        finalScoreHtml = `<span class="${finalScoreClass}">${finalScore}</span>`;
                    }
                }
                
                                 // Формируем ячейку K60 с tooltip
                 let k60Cell = '';
                 const statsFormatted = formatStats(match.stats_60min);
                 const hasLiveOdds = match.live_odds !== null && match.live_odds !== undefined;
                 
                 if (statsFormatted) {
                     // Есть статистика - показываем tooltip
                     if (hasLiveOdds) {
                         // Есть и коэффициент, и статистика
                         k60Cell = `
                             <span class="stats-tooltip" data-tooltip-position="">
                                 <span class="odds">${match.live_odds}</span>
                                 <span class="tooltip-content">${statsFormatted.replace(/\n/g, '<br>')}</span>
                             </span>
                         `;
                     } else {
                         // Нет коэффициента, но есть статистика - показываем иконку информации
                         k60Cell = `
                             <span class="stats-tooltip" data-tooltip-position="">
                                 <i class="fas fa-info-circle info-icon"></i>
                                 <span class="tooltip-content">${statsFormatted.replace(/\n/g, '<br>')}</span>
                             </span>
                         `;
                     }
                 } else {
                     // Нет статистики - просто показываем коэффициент или "-"
                     k60Cell = `<span class="odds">${match.live_odds || '-'}</span>`;
                 }
                 
                row.innerHTML = `
                    <td>${match.match_date}</td>
                    <td>${match.match_time}</td>
                    <td>${match.home_team}</td>
                    <td>${match.away_team}</td>
                    <td><span class="fav-team">${match.fav}</span></td>
                    <td><span class="odds">${match.initial_odds || '-'}</span></td>
                    <td><span class="odds">${match.last_odds || '-'}</span></td>
                    <td>${k60Cell}</td>
                    <td>${(match.bet && parseFloat(match.bet) >= 1) ? '<i class="fas fa-check text-success"></i>' : ''}</td>
                    <td>${match.bet_ai ? (match.bet_ai_odds ? `<span class="odds">${match.bet_ai} <small>(${parseFloat(match.bet_ai_odds).toFixed(2)})</small></span>` : match.bet_ai) : '-'}</td>
                    <td>${finalScoreHtml}</td>
                    <td><span class="status-badge ${statusBadgeClass}">${statusText}</span></td>
                `;
                
                                 tbody.appendChild(row);
             });
             
             // Рассчитываем и отображаем итоги
             calculateTotals(matches);
             
             // Настраиваем позицию tooltip'ов после добавления строк в DOM
             setTimeout(() => {
                 adjustTooltipPositions();
             }, 0);
         }
         
         function updateTooltipPosition(tooltip) {
             const tooltipContent = tooltip.querySelector('.tooltip-content');
             if (!tooltipContent) return;
             
             const rect = tooltip.getBoundingClientRect();
             const tooltipHeight = 250; // Примерная высота tooltip
             const spaceAbove = rect.top;
             const spaceBelow = window.innerHeight - rect.bottom;
             
             // Определяем, где больше места
             if (spaceAbove < tooltipHeight && spaceBelow >= tooltipHeight) {
                 // Показываем снизу
                 tooltip.classList.add('tooltip-bottom');
                 tooltipContent.style.top = (rect.bottom + 10) + 'px';
                 tooltipContent.style.left = (rect.left + rect.width / 2) + 'px';
                 tooltipContent.style.bottom = 'auto';
                 tooltipContent.style.right = 'auto';
                 tooltipContent.style.transform = 'translateX(-50%)';
             } else {
                 // Показываем сверху (по умолчанию)
                 tooltip.classList.remove('tooltip-bottom');
                 const topPos = Math.max(10, rect.top - tooltipHeight - 10);
                 tooltipContent.style.top = topPos + 'px';
                 tooltipContent.style.left = (rect.left + rect.width / 2) + 'px';
                 tooltipContent.style.bottom = 'auto';
                 tooltipContent.style.right = 'auto';
                 tooltipContent.style.transform = 'translateX(-50%)';
             }
         }
         
         function adjustTooltipPositions() {
             const tooltips = document.querySelectorAll('.stats-tooltip');
             
             tooltips.forEach(tooltip => {
                 const tooltipContent = tooltip.querySelector('.tooltip-content');
                 if (!tooltipContent) return;
                 
                 // Добавляем обработчик для динамического определения позиции при наведении
                 tooltip.addEventListener('mouseenter', function(e) {
                     updateTooltipPosition(this);
                 });
                 
                 // Обновляем позицию при движении мыши, если tooltip видим
                 let isTooltipVisible = false;
                 tooltip.addEventListener('mouseenter', function() {
                     isTooltipVisible = true;
                 });
                 tooltip.addEventListener('mouseleave', function() {
                     isTooltipVisible = false;
                 });
             });
             
             // Обновляем позицию при скролле страницы для видимых tooltip'ов
             let scrollHandler = function() {
                 tooltips.forEach(tooltip => {
                     const tooltipContent = tooltip.querySelector('.tooltip-content');
                     if (tooltipContent) {
                         const style = window.getComputedStyle(tooltipContent);
                         if (style.visibility === 'visible' && parseFloat(style.opacity) > 0) {
                             updateTooltipPosition(tooltip);
                         }
                     }
                 });
             };
             window.addEventListener('scroll', scrollHandler, true);
             window.addEventListener('resize', scrollHandler);
         }

        // Проверяем режим администратора
        const urlParams = new URLSearchParams(window.location.search);
        const isAdmin = urlParams.get('admin') === 'true';
        
        // Загружаем матчи при загрузке страницы
        loadMatches();
        
        // Загружаем лимиты только в режиме администратора
        if (isAdmin) {
            loadLimits();
        }
    </script>
</body>
</html>

