<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Football Betting Analysis</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .main-content {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            margin: 20px auto;
            padding: 30px;
            max-width: 1400px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .table-responsive {
            overflow-x: auto;
        }
        
        .table {
            font-size: 0.9rem;
        }
        
        .status-badge {
            font-size: 0.8rem;
            border-radius: 20px;
            padding: 5px 12px;
        }
        
        .status-scheduled {
            background-color: #ffc107;
            color: #000;
        }
        
        .status-in_progress {
            background-color: #0d6efd;
            color: white;
        }
        
        .status-finished {
            background-color: #198754;
            color: white;
        }
        
        .final-score-win {
            background-color: #28a745;
            color: white;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .final-score-loss {
            background-color: #dc3545;
            color: white;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .final-score-draw {
            background-color: #ffc107;
            color: #000;
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .fav-team {
            font-weight: bold;
            color: #0d6efd;
        }
        
        .odds {
            font-weight: bold;
            color: #198754;
        }
        
        h1 {
            color: #1e3c72;
            margin-bottom: 30px;
        }
        
        .stats-col {
            white-space: pre-wrap;
            font-size: 0.85rem;
            max-width: 300px;
        }
        
        .api-limits-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .api-limits-card h5 {
            color: white;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .limits-row {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        .limit-item {
            text-align: center;
            flex: 1;
            min-width: 150px;
        }
        
        .limit-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .limit-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .limit-warning {
            color: #ffc107;
        }
        
        .limit-critical {
            color: #dc3545;
        }
        
        .limit-ok {
            color: #28a745;
        }
        
        .sortable-header, .sortable-header-all {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px !important;
        }
        
        .sortable-header:hover, .sortable-header-all:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }
        
        .sortable-header::after, .sortable-header-all::after {
            content: '↕';
            position: absolute;
            right: 5px;
            opacity: 0.3;
            font-size: 0.8em;
        }
        
        .sortable-header.sort-asc::after, .sortable-header-all.sort-asc::after {
            content: '↑';
            opacity: 1;
            color: #0d6efd;
        }
        
        .sortable-header.sort-desc::after, .sortable-header-all.sort-desc::after {
            content: '↓';
            opacity: 1;
            color: #0d6efd;
        }
        
        .stats-tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
        }
        
                 .stats-tooltip .tooltip-content {
             visibility: hidden;
             position: fixed;
             background-color: #333;
             color: white;
             text-align: left;
             border-radius: 8px;
             padding: 12px;
             font-size: 0.85rem;
             white-space: pre-line;
             z-index: 10000;
             min-width: 300px;
             max-width: 500px;
             box-shadow: 0 4px 6px rgba(0,0,0,0.3);
             opacity: 0;
             transition: opacity 0.3s;
             pointer-events: none;
         }
         
         .stats-tooltip:hover .tooltip-content {
             visibility: visible;
             opacity: 1;
         }
         
         .stats-tooltip .tooltip-content::after {
             content: "";
             position: absolute;
             top: 100%;
             left: 50%;
             transform: translateX(-50%);
             border-width: 5px;
             border-style: solid;
             border-color: #333 transparent transparent transparent;
         }
         
         .stats-tooltip.tooltip-bottom .tooltip-content::after {
             top: auto;
             bottom: 100%;
             border-color: transparent transparent #333 transparent;
         }
         
         .table-responsive {
             overflow-x: auto;
             overflow-y: visible;
         }
        
        .info-icon {
            color: #17a2b8;
            cursor: help;
        }
        
        /* Стили для красной буквы "ai" в заголовке */
        .ai-logo-a {
            color: #b23c17;
        }
        
        /* Стили для markdown контента в модальном окне анализа риска */
        .analysis-text {
            font-size: 1rem;
            line-height: 1.8;
        }
        
        .analysis-text h1,
        .analysis-text h2,
        .analysis-text h3,
        .analysis-text h4,
        .analysis-text h5,
        .analysis-text h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
            color: #1e3c72;
        }
        
        .analysis-text h1 { font-size: 1.75rem; }
        .analysis-text h2 { font-size: 1.5rem; }
        .analysis-text h3 { font-size: 1.25rem; }
        .analysis-text h4 { font-size: 1.1rem; }
        
        .analysis-text p {
            margin-bottom: 1em;
        }
        
        .analysis-text ul,
        .analysis-text ol {
            margin-bottom: 1em;
            padding-left: 2em;
        }
        
        .analysis-text li {
            margin-bottom: 0.5em;
        }
        
        .analysis-text strong {
            font-weight: 600;
            color: #1e3c72;
        }
        
        .analysis-text em {
            font-style: italic;
        }
        
        .analysis-text code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .analysis-text pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin-bottom: 1em;
        }
        
        .analysis-text pre code {
            background-color: transparent;
            padding: 0;
        }
        
        .analysis-text blockquote {
            border-left: 4px solid #0d6efd;
            padding-left: 1em;
            margin-left: 0;
            margin-bottom: 1em;
            color: #666;
            font-style: italic;
        }
        
        .analysis-text hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 1.5em 0;
        }
        
        .analysis-text table {
            border-collapse: collapse;
            width: 100%;
            margin-bottom: 1em;
        }
        
        .analysis-text table th,
        .analysis-text table td {
            border: 1px solid #ddd;
            padding: 8px 12px;
            text-align: left;
        }
        
        .analysis-text table th {
            background-color: #f8f9fa;
            font-weight: 600;
        }
        
        /* Подсветка строк с коэффициентами, где разница между победами не более 0.2 */
        #all-matches-container tbody tr.match-balanced-odds {
            background-color: #d4edda !important;
        }
        
        #all-matches-container tbody tr.match-balanced-odds:nth-child(even) {
            background-color: #d4edda !important;
        }
        
        #all-matches-container tbody tr.match-balanced-odds:nth-child(odd) {
            background-color: #d4edda !important;
        }
        
        #all-matches-container tbody tr.match-balanced-odds:hover {
            background-color: #c3e6cb !important;
        }
        
        #all-matches-container tbody tr.match-balanced-odds td {
            background-color: transparent !important;
        }
        
        /* Подсветка матчей с фаворитами (коэффициент < 1.30) */
        #all-matches-container tbody tr.match-with-favorite {
            background-color: #f8d7da !important;
        }
        
        #all-matches-container tbody tr.match-with-favorite:nth-child(even) {
            background-color: #f8d7da !important;
        }
        
        #all-matches-container tbody tr.match-with-favorite:nth-child(odd) {
            background-color: #f8d7da !important;
        }
        
        #all-matches-container tbody tr.match-with-favorite:hover {
            background-color: #f5c2c7 !important;
        }
        
        #all-matches-container tbody tr.match-with-favorite td {
            background-color: transparent !important;
        }
        
        /* Подсветка матчей, где фаворит "просел" (был фаворит, но коэффициент вырос >= 1.30) */
        #all-matches-container tbody tr.match-favorite-declined {
            background-color: #e7d5f5 !important;
        }
        
        #all-matches-container tbody tr.match-favorite-declined:nth-child(even) {
            background-color: #e7d5f5 !important;
        }
        
        #all-matches-container tbody tr.match-favorite-declined:nth-child(odd) {
            background-color: #e7d5f5 !important;
        }
        
        #all-matches-container tbody tr.match-favorite-declined:hover {
            background-color: #d9c0eb !important;
        }
        
        #all-matches-container tbody tr.match-favorite-declined td {
            background-color: transparent !important;
        }
    </style>
</head>
<body>
    <div class="main-content">
        <div class="d-flex justify-content-between align-items-center mb-4">
            <h1><i class="fas fa-futbol"></i> Футбольная <span class="ai-logo-a">ai</span>налитика</h1>
            {% if admin %}
            <div>
                <button class="btn btn-primary" id="sync-button" onclick="syncAndLoad()">
                    <i class="fas fa-sync-alt" id="sync-icon"></i> <span id="sync-text">Обновить</span>
                </button>
                <div class="spinner-border spinner-border-sm text-primary ms-2" id="sync-spinner" role="status" style="display: none;">
                    <span class="visually-hidden">Синхронизация...</span>
                </div>
            </div>
            {% endif %}
        </div>
        
        {% if admin %}
        <!-- Блок лимитов API -->
        <div class="api-limits-card" id="api-limits-card">
            <h5><i class="fas fa-chart-line"></i> Лимиты API The Odds API</h5>
            <div class="limits-row" id="limits-row">
                <div class="limit-item">
                    <div class="limit-value" id="limit-remaining">-</div>
                    <div class="limit-label">Осталось запросов</div>
                </div>
                <div class="limit-item">
                    <div class="limit-value" id="limit-used">-</div>
                    <div class="limit-label">Использовано</div>
                </div>
                <div class="limit-item">
                    <div class="limit-value" id="limit-cost">-</div>
                    <div class="limit-label">Стоимость последнего</div>
                </div>
            </div>
        </div>
        {% endif %}
        
        <!-- Вкладки -->
        <ul class="nav nav-tabs mb-4" id="matches-tabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="fav-tab" type="button" role="tab" aria-controls="fav-matches" aria-selected="true">
                    <i class="fas fa-star"></i> С фаворитом
                </button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="all-tab" type="button" role="tab" aria-controls="all-matches" aria-selected="false">
                    <i class="fas fa-list"></i> Все матчи
                </button>
            </li>
        </ul>
        
        <div id="loading" class="text-center my-5">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Загрузка...</span>
            </div>
        </div>
        
        <div class="tab-content" id="matches-tab-content">
            <!-- Вкладка с матчами с фаворитом -->
            <div class="tab-pane fade show active" id="fav-matches" role="tabpanel" aria-labelledby="fav-tab">
                <!-- Фильтр по датам для первой таблицы -->
                <div class="date-filter mb-3">
                    <div class="btn-group" role="group" aria-label="Фильтр по датам">
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn active" data-filter="all">Все время</button>
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn" data-filter="yesterday">Вчера</button>
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn" data-filter="today">Сегодня</button>
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn" data-filter="tomorrow">Завтра</button>
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn" data-filter="range">Период</button>
                    </div>
                    <div id="date-range-picker-fav" class="mt-2" style="display: none;">
                        <input type="date" id="date-from-fav" class="form-control form-control-sm d-inline-block" style="width: 150px;">
                        <span class="mx-2">-</span>
                        <input type="date" id="date-to-fav" class="form-control form-control-sm d-inline-block" style="width: 150px;">
                        <button type="button" class="btn btn-sm btn-primary ms-2" onclick="applyDateRangeFilter('fav')">Применить</button>
                    </div>
                </div>
                <div id="matches-container" style="display: none;">
            <div class="table-responsive">
                <table class="table table-striped table-hover">
                    <thead>
                        <tr>
                            <th class="sortable-header" data-sort="match_date">Дата</th>
                            <th class="sortable-header" data-sort="match_time">Время</th>
                            <th class="sortable-header" data-sort="home_team">Хозяева</th>
                            <th class="sortable-header" data-sort="away_team">Гости</th>
                            <th class="sortable-header" data-sort="fav">Фаворит</th>
                            <th class="sortable-header" data-sort="initial_odds">K0</th>
                            <th class="sortable-header" data-sort="last_odds">K1</th>
                            <th class="sortable-header" data-sort="live_odds">K60</th>
                            <th class="sortable-header" data-sort="bet_ai">Прогноз ИИ</th>
                            <th class="sortable-header" data-sort="bet">Bet</th>
                            <th class="sortable-header" data-sort="final_score">Итоговый счёт</th>
                            <th class="sortable-header" data-sort="status">Статус</th>
                        </tr>
                    </thead>
                    <tbody id="matches-table-body">
                    </tbody>
                    <tfoot id="totals-row" style="display: none;">
                        <tr style="background-color: #f8f9fa; font-weight: bold;">
                            <td colspan="5" style="text-align: right;">Итого:</td>
                            <td id="total-k0" class="odds">-</td>
                            <td id="total-k1" class="odds">-</td>
                            <td id="total-k60" class="odds">-</td>
                            <td id="total-bet-ai" class="odds">-</td>
                            <td id="total-bet" class="odds">-</td>
                            <td></td>
                            <td></td>
                        </tr>
                    </tfoot>
                </table>
            </div>
            <div id="empty-state" class="text-center my-5" style="display: none;">
                <i class="fas fa-futbol fa-3x text-muted mb-3"></i>
                <p class="text-muted">Нет матчей для отображения</p>
            </div>
                </div>
            </div>
            
            <!-- Вкладка со всеми матчами -->
            <div class="tab-pane fade" id="all-matches" role="tabpanel" aria-labelledby="all-tab">
                <!-- Фильтр по датам для второй таблицы -->
                <div class="date-filter mb-3">
                    <div class="btn-group" role="group" aria-label="Фильтр по датам">
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn-all active" data-filter="all">Все время</button>
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn-all" data-filter="yesterday">Вчера</button>
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn-all" data-filter="today">Сегодня</button>
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn-all" data-filter="tomorrow">Завтра</button>
                        <button type="button" class="btn btn-sm btn-outline-primary date-filter-btn-all" data-filter="range">Период</button>
                    </div>
                    <div id="date-range-picker-all" class="mt-2" style="display: none;">
                        <input type="date" id="date-from-all" class="form-control form-control-sm d-inline-block" style="width: 150px;">
                        <span class="mx-2">-</span>
                        <input type="date" id="date-to-all" class="form-control form-control-sm d-inline-block" style="width: 150px;">
                        <button type="button" class="btn btn-sm btn-primary ms-2" onclick="applyDateRangeFilter('all')">Применить</button>
                    </div>
                </div>
                <div id="all-matches-container" style="display: none;">
                    <div class="table-responsive">
                        <table class="table table-striped table-hover">
                            <thead>
                                <tr>
                                    <th class="sortable-header-all" data-sort="match_date">Дата</th>
                                    <th class="sortable-header-all" data-sort="match_time">Время</th>
                                    <th class="sortable-header-all" data-sort="home_team">Хозяева</th>
                                    <th class="sortable-header-all" data-sort="away_team">Гости</th>
                                    <th class="sortable-header-all" data-sort="live_odds_1">1</th>
                                    <th class="sortable-header-all" data-sort="live_odds_x">X</th>
                                    <th class="sortable-header-all" data-sort="live_odds_2">2</th>
                            <th class="sortable-header-all" data-sort="bet_ai">Прогноз ИИ</th>
                            <th class="sortable-header-all" data-sort="bet">Bet</th>
                            <th class="sortable-header-all" data-sort="final_score">Итоговый счёт</th>
                            <th class="sortable-header-all" data-sort="status">Статус</th>
                                </tr>
                            </thead>
                            <tbody id="all-matches-table-body">
                            </tbody>
                            <tfoot id="totals-row-all" style="display: none;">
                                <tr style="background-color: #f8f9fa; font-weight: bold;">
                                    <td colspan="7" style="text-align: right;">Итого:</td>
                                    <td id="total-bet-ai-all" class="odds">-</td>
                                    <td id="total-bet-all" class="odds">-</td>
                                    <td></td>
                                    <td></td>
                                </tr>
                            </tfoot>
                        </table>
                    </div>
                    <div id="all-matches-empty-state" class="text-center my-5" style="display: none;">
                        <i class="fas fa-futbol fa-3x text-muted mb-3"></i>
                        <p class="text-muted">Нет матчей для отображения</p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Модальное окно для анализа риска -->
        <div class="modal fade" id="riskAnalysisModal" tabindex="-1" aria-labelledby="riskAnalysisModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="riskAnalysisModalLabel">Анализ риска ставки</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body" id="riskAnalysisContent">
                        <div class="text-center">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Загрузка анализа...</span>
                            </div>
                            <p class="mt-2">Запрос анализа риска...</p>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Модальное окно для виджета SofaScore -->
        <div class="modal fade" id="sofascoreModal" tabindex="-1" aria-labelledby="sofascoreModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-xl">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="sofascoreModalLabel">Матч в прямом эфире</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body" id="sofascoreContent">
                        <div id="sofascoreWidgetContainer">
                            <div class="text-center">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Загрузка виджета...</span>
                                </div>
                                <p class="mt-2">Загрузка виджета...</p>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Закрыть</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Глобальная переменная для хранения данных матчей
        let allMatches = [];
        let allMatchesData = [];
        let currentSortField = null;
        let currentSortDirection = 'asc';

        // Переменные для сортировки второй таблицы
        let currentSortFieldAll = null;
        let currentSortDirectionAll = 'asc';
        
        // Переменные для фильтрации по датам
        let currentDateFilterFav = 'all';
        let currentDateFilterAll = 'all';
        let dateRangeFav = { from: null, to: null };
        let dateRangeAll = { from: null, to: null };
        
        // Инициализация обработчиков сортировки
        document.addEventListener('DOMContentLoaded', function() {
            // Обработчики для первой таблицы (с фаворитом)
            const headers = document.querySelectorAll('.sortable-header');
            headers.forEach(header => {
                header.addEventListener('click', function() {
                    const sortField = this.getAttribute('data-sort');
                    sortTable(sortField);
                });
            });
            
            // Обработчики для второй таблицы (все матчи)
            const headersAll = document.querySelectorAll('.sortable-header-all');
            headersAll.forEach(header => {
                header.addEventListener('click', function() {
                    const sortField = this.getAttribute('data-sort');
                    sortTableAll(sortField);
                });
            });
            
            // Обработчики для фильтров по датам (первая таблица)
            document.querySelectorAll('.date-filter-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const filter = this.getAttribute('data-filter');
                    setDateFilter('fav', filter);
                });
            });
            
            // Обработчики для фильтров по датам (вторая таблица)
            document.querySelectorAll('.date-filter-btn-all').forEach(btn => {
                btn.addEventListener('click', function() {
                    const filter = this.getAttribute('data-filter');
                    setDateFilter('all', filter);
                });
            });
        });
        
        // Функция для установки фильтра по датам
        function setDateFilter(table, filter) {
            if (table === 'fav') {
                currentDateFilterFav = filter;
                // Обновляем активную кнопку
                document.querySelectorAll('.date-filter-btn').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('data-filter') === filter) {
                        btn.classList.add('active');
                    }
                });
                // Показываем/скрываем выбор диапазона дат
                const rangePicker = document.getElementById('date-range-picker-fav');
                if (filter === 'range') {
                    rangePicker.style.display = 'block';
                } else {
                    rangePicker.style.display = 'none';
                    dateRangeFav = { from: null, to: null };
                }
                // Применяем фильтр и перерисовываем таблицу
                applyDateFilter('fav');
            } else if (table === 'all') {
                currentDateFilterAll = filter;
                // Обновляем активную кнопку
                document.querySelectorAll('.date-filter-btn-all').forEach(btn => {
                    btn.classList.remove('active');
                    if (btn.getAttribute('data-filter') === filter) {
                        btn.classList.add('active');
                    }
                });
                // Показываем/скрываем выбор диапазона дат
                const rangePicker = document.getElementById('date-range-picker-all');
                if (filter === 'range') {
                    rangePicker.style.display = 'block';
                } else {
                    rangePicker.style.display = 'none';
                    dateRangeAll = { from: null, to: null };
                }
                // Применяем фильтр и перерисовываем таблицу
                applyDateFilter('all');
            }
        }
        
        // Функция для применения фильтра диапазона дат
        function applyDateRangeFilter(table) {
            if (table === 'fav') {
                const fromInput = document.getElementById('date-from-fav');
                const toInput = document.getElementById('date-to-fav');
                if (fromInput && toInput) {
                    dateRangeFav.from = fromInput.value;
                    dateRangeFav.to = toInput.value;
                    applyDateFilter('fav');
                }
            } else if (table === 'all') {
                const fromInput = document.getElementById('date-from-all');
                const toInput = document.getElementById('date-to-all');
                if (fromInput && toInput) {
                    dateRangeAll.from = fromInput.value;
                    dateRangeAll.to = toInput.value;
                    applyDateFilter('all');
                }
            }
        }
        
        // Функция для получения локальной даты в формате YYYY-MM-DD
        function getLocalDateString(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        // Функция для фильтрации матчей по дате
        function filterMatchesByDate(matches, filterType, dateRange) {
            if (filterType === 'all') {
                return matches;
            }
            
            // Используем локальное время для определения даты
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            let filterDateStr = null;
            
            if (filterType === 'today') {
                filterDateStr = getLocalDateString(today);
            } else if (filterType === 'yesterday') {
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);
                filterDateStr = getLocalDateString(yesterday);
            } else if (filterType === 'tomorrow') {
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);
                filterDateStr = getLocalDateString(tomorrow);
            } else if (filterType === 'range') {
                if (!dateRange.from || !dateRange.to) {
                    return matches;
                }
                // Для диапазона используем локальное время
                const fromDate = new Date(dateRange.from + 'T00:00:00');
                const toDate = new Date(dateRange.to + 'T23:59:59');
                
                return matches.filter(match => {
                    if (!match.match_date) return false;
                    // Создаем дату матча в локальном времени
                    const matchDateStr = match.match_date;
                    const matchTimeStr = match.match_time || '00:00:00';
                    const matchDate = new Date(matchDateStr + 'T' + matchTimeStr);
                    return matchDate >= fromDate && matchDate <= toDate;
                });
            }
            
            if (!filterDateStr) {
                return matches;
            }
            
            // Фильтруем по строке даты (уже в формате YYYY-MM-DD)
            return matches.filter(match => {
                if (!match.match_date) return false;
                return match.match_date === filterDateStr;
            });
        }
        
        // Функция для применения фильтра и перерисовки таблицы
        function applyDateFilter(table) {
            if (table === 'fav') {
                const filtered = filterMatchesByDate(allMatches, currentDateFilterFav, dateRangeFav);
                if (currentSortField) {
                    // Применяем текущую сортировку без изменения направления
                    applyCurrentSort('fav', filtered);
                } else {
                    displayMatches(filtered);
                }
            } else if (table === 'all') {
                const filtered = filterMatchesByDate(allMatchesData, currentDateFilterAll, dateRangeAll);
                if (currentSortFieldAll) {
                    // Применяем текущую сортировку без изменения направления
                    applyCurrentSort('all', filtered);
                } else {
                    displayAllMatches(filtered);
                }
            }
        }
        
        // Функция для применения текущей сортировки без изменения направления (используется при фильтрации)
        function applyCurrentSort(table, matchesToSort) {
            if (table === 'fav') {
                if (!matchesToSort || matchesToSort.length === 0) {
                    displayMatches([]);
                    return;
                }
                
                const field = currentSortField;
                const direction = currentSortDirection;
                
                // Обновляем визуальные индикаторы сортировки
                document.querySelectorAll('.sortable-header').forEach(h => {
                    h.classList.remove('sort-asc', 'sort-desc');
                });
                const currentHeader = document.querySelector(`.sortable-header[data-sort="${field}"]`);
                if (currentHeader) {
                    currentHeader.classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
                
                // Сортируем массив
                const sortedMatches = [...matchesToSort].sort((a, b) => {
                    let valueA = a[field];
                    let valueB = b[field];

                    // Специальная обработка для разных типов полей
                    if (field === 'final_score') {
                        const scoreA = (a.final_score_home || 0) + (a.final_score_away || 0);
                        const scoreB = (b.final_score_home || 0) + (b.final_score_away || 0);
                        valueA = scoreA;
                        valueB = scoreB;
                    } else if (field === 'match_date' || field === 'match_time') {
                        const dateTimeA = new Date(`${a.match_date}T${a.match_time || '00:00'}`);
                        const dateTimeB = new Date(`${b.match_date}T${b.match_time || '00:00'}`);
                        valueA = dateTimeA.getTime();
                        valueB = dateTimeB.getTime();
                    } else if (field === 'initial_odds' || field === 'last_odds' || field === 'live_odds' || field === 'bet') {
                        valueA = parseFloat(valueA) || 0;
                        valueB = parseFloat(valueB) || 0;
                    } else if (field === 'status') {
                        const statusOrder = {'scheduled': 1, 'in_progress': 2, 'finished': 3};
                        valueA = statusOrder[valueA] || 999;
                        valueB = statusOrder[valueB] || 999;
                    }

                    // Обработка null/undefined
                    if (valueA == null) valueA = '';
                    if (valueB == null) valueB = '';

                    // Сравнение
                    if (valueA < valueB) {
                        return direction === 'asc' ? -1 : 1;
                    } else if (valueA > valueB) {
                        return direction === 'asc' ? 1 : -1;
                    }
                    return 0;
                });

                displayMatches(sortedMatches);
            } else if (table === 'all') {
                if (!matchesToSort || matchesToSort.length === 0) {
                    displayAllMatches([]);
                    return;
                }
                
                const field = currentSortFieldAll;
                const direction = currentSortDirectionAll;
                
                // Обновляем визуальные индикаторы сортировки
                document.querySelectorAll('.sortable-header-all').forEach(h => {
                    h.classList.remove('sort-asc', 'sort-desc');
                });
                const currentHeader = document.querySelector(`.sortable-header-all[data-sort="${field}"]`);
                if (currentHeader) {
                    currentHeader.classList.add(direction === 'asc' ? 'sort-asc' : 'sort-desc');
                }
                
                // Сортируем массив
                const sortedMatches = [...matchesToSort].sort((a, b) => {
                    let valueA = a[field];
                    let valueB = b[field];

                    // Специальная обработка для разных типов полей
                    if (field === 'final_score') {
                        const scoreA = (a.final_score_home || 0) + (a.final_score_away || 0);
                        const scoreB = (b.final_score_home || 0) + (b.final_score_away || 0);
                        valueA = scoreA;
                        valueB = scoreB;
                    } else if (field === 'match_date' || field === 'match_time') {
                        const dateTimeA = new Date(`${a.match_date}T${a.match_time || '00:00'}`);
                        const dateTimeB = new Date(`${b.match_date}T${b.match_time || '00:00'}`);
                        valueA = dateTimeA.getTime();
                        valueB = dateTimeB.getTime();
                    } else if (field === 'live_odds_1' || field === 'live_odds_x' || field === 'live_odds_2') {
                        valueA = parseFloat(valueA) || 0;
                        valueB = parseFloat(valueB) || 0;
                    } else if (field === 'status') {
                        const statusOrder = {'scheduled': 1, 'in_progress': 2, 'finished': 3};
                        valueA = statusOrder[valueA] || 999;
                        valueB = statusOrder[valueB] || 999;
                    }

                    // Обработка null/undefined
                    if (valueA == null) valueA = '';
                    if (valueB == null) valueB = '';

                    // Сравнение
                    if (valueA < valueB) {
                        return direction === 'asc' ? -1 : 1;
                    } else if (valueA > valueB) {
                        return direction === 'asc' ? 1 : -1;
                    }
                    return 0;
                });

                displayAllMatches(sortedMatches);
            }
        }

        function sortTable(field, matchesToSort = null) {
            // Используем переданные матчи или применяем фильтр к allMatches
            let matches = matchesToSort;
            if (!matches) {
                matches = filterMatchesByDate(allMatches, currentDateFilterFav, dateRangeFav);
            }
            
            if (!matches || matches.length === 0) {
                // Показываем пустую таблицу, если нет отфильтрованных матчей
                displayMatches([]);
                return;
            }

            // Если кликнули по тому же полю - меняем направление, иначе сортируем по возрастанию
            if (currentSortField === field) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortField = field;
                currentSortDirection = 'asc';
            }

            // Сбрасываем классы сортировки со всех заголовков
            document.querySelectorAll('.sortable-header').forEach(h => {
                h.classList.remove('sort-asc', 'sort-desc');
            });

            // Добавляем класс к текущему заголовку
            const currentHeader = document.querySelector(`.sortable-header[data-sort="${field}"]`);
            if (currentHeader) {
                currentHeader.classList.add(currentSortDirection === 'asc' ? 'sort-asc' : 'sort-desc');
            }

            // Сортируем массив
            const sortedMatches = [...matches].sort((a, b) => {
                let valueA = a[field];
                let valueB = b[field];

                // Специальная обработка для разных типов полей
                if (field === 'final_score') {
                    // Для итогового счета - сравниваем сумму голов
                    const scoreA = (a.final_score_home || 0) + (a.final_score_away || 0);
                    const scoreB = (b.final_score_home || 0) + (b.final_score_away || 0);
                    valueA = scoreA;
                    valueB = scoreB;
                } else if (field === 'match_date' || field === 'match_time') {
                    // Для даты и времени - создаем полную дату для сравнения
                    const dateTimeA = new Date(`${a.match_date}T${a.match_time || '00:00'}`);
                    const dateTimeB = new Date(`${b.match_date}T${b.match_time || '00:00'}`);
                    valueA = dateTimeA.getTime();
                    valueB = dateTimeB.getTime();
                } else if (field === 'initial_odds' || field === 'last_odds' || field === 'live_odds' || field === 'bet') {
                    // Для коэффициентов - преобразуем в числа
                    valueA = parseFloat(valueA) || 0;
                    valueB = parseFloat(valueB) || 0;
                } else if (field === 'status') {
                    // Для статуса - используем порядок: scheduled < in_progress < finished
                    const statusOrder = {'scheduled': 1, 'in_progress': 2, 'finished': 3};
                    valueA = statusOrder[valueA] || 999;
                    valueB = statusOrder[valueB] || 999;
                }

                // Обработка null/undefined
                if (valueA == null) valueA = '';
                if (valueB == null) valueB = '';

                // Сравнение
                if (valueA < valueB) {
                    return currentSortDirection === 'asc' ? -1 : 1;
                } else if (valueA > valueB) {
                    return currentSortDirection === 'asc' ? 1 : -1;
                }
                return 0;
            });

            // Обновляем отображение
            displayMatches(sortedMatches);
        }
        
        function sortTableAll(field, matchesToSort = null) {
            // Используем переданные матчи или применяем фильтр к allMatchesData
            let matches = matchesToSort;
            if (!matches) {
                matches = filterMatchesByDate(allMatchesData, currentDateFilterAll, dateRangeAll);
            }
            
            if (!matches || matches.length === 0) {
                // Показываем пустую таблицу, если нет отфильтрованных матчей
                displayAllMatches([]);
                return;
            }

            // Если кликнули по тому же полю - меняем направление, иначе сортируем по возрастанию
            if (currentSortFieldAll === field) {
                currentSortDirectionAll = currentSortDirectionAll === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortFieldAll = field;
                currentSortDirectionAll = 'asc';
            }

            // Сбрасываем классы сортировки со всех заголовков
            document.querySelectorAll('.sortable-header-all').forEach(h => {
                h.classList.remove('sort-asc', 'sort-desc');
            });

            // Добавляем класс к текущему заголовку
            const currentHeader = document.querySelector(`.sortable-header-all[data-sort="${field}"]`);
            if (currentHeader) {
                currentHeader.classList.add(currentSortDirectionAll === 'asc' ? 'sort-asc' : 'sort-desc');
            }

            // Сортируем массив
            const sortedMatches = [...matches].sort((a, b) => {
                let valueA = a[field];
                let valueB = b[field];

                // Специальная обработка для разных типов полей
                if (field === 'final_score') {
                    // Для итогового счета - сравниваем сумму голов
                    const scoreA = (a.final_score_home || 0) + (a.final_score_away || 0);
                    const scoreB = (b.final_score_home || 0) + (b.final_score_away || 0);
                    valueA = scoreA;
                    valueB = scoreB;
                } else if (field === 'match_date' || field === 'match_time') {
                    // Для даты и времени - создаем полную дату для сравнения
                    const dateTimeA = new Date(`${a.match_date}T${a.match_time || '00:00'}`);
                    const dateTimeB = new Date(`${b.match_date}T${b.match_time || '00:00'}`);
                    valueA = dateTimeA.getTime();
                    valueB = dateTimeB.getTime();
                } else if (field === 'live_odds_1' || field === 'live_odds_x' || field === 'live_odds_2') {
                    // Для коэффициентов - преобразуем в числа
                    valueA = parseFloat(valueA) || 0;
                    valueB = parseFloat(valueB) || 0;
                } else if (field === 'status') {
                    // Для статуса - используем порядок: scheduled < in_progress < finished
                    const statusOrder = {'scheduled': 1, 'in_progress': 2, 'finished': 3};
                    valueA = statusOrder[valueA] || 999;
                    valueB = statusOrder[valueB] || 999;
                }

                // Обработка null/undefined
                if (valueA == null) valueA = '';
                if (valueB == null) valueB = '';

                // Сравнение
                if (valueA < valueB) {
                    return currentSortDirectionAll === 'asc' ? -1 : 1;
                } else if (valueA > valueB) {
                    return currentSortDirectionAll === 'asc' ? 1 : -1;
                }
                return 0;
            });

            // Обновляем отображение
            displayAllMatches(sortedMatches);
        }

        function syncAndLoad() {
            const syncButton = document.getElementById('sync-button');
            const syncIcon = document.getElementById('sync-icon');
            const syncText = document.getElementById('sync-text');
            const syncSpinner = document.getElementById('sync-spinner');
            
            // Блокируем кнопку и показываем спиннер
            syncButton.disabled = true;
            syncIcon.style.display = 'none';
            syncText.textContent = 'Синхронизация...';
            syncSpinner.style.display = 'inline-block';
            
            // Запускаем синхронизацию
            fetch('/api/football/sync', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Синхронизация завершена:', data.stats);
                    // После синхронизации запускаем проверку матчей
                    syncText.textContent = 'Проверка матчей...';
                    return fetch('/api/football/check', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                } else {
                    console.error('Ошибка синхронизации:', data.error);
                    alert('Ошибка синхронизации: ' + (data.error || 'Неизвестная ошибка'));
                    throw new Error('Синхронизация не удалась');
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('Проверка матчей завершена');
                    // После успешной проверки загружаем обновленные данные
                    loadMatches();
                    if (isAdmin) {
                        loadLimits();
                    }
                } else {
                    console.error('Ошибка проверки матчей:', data.error);
                    alert('Ошибка проверки матчей: ' + (data.error || 'Неизвестная ошибка'));
                    // Всё равно обновляем данные
                    loadMatches();
                    if (isAdmin) {
                        loadLimits();
                    }
                }
            })
            .catch(error => {
                console.error('Ошибка запроса:', error);
                alert('Ошибка: ' + error.message);
                // Всё равно обновляем данные
                loadMatches();
                if (isAdmin) {
                    loadLimits();
                }
            })
            .finally(() => {
                // Восстанавливаем кнопку
                syncButton.disabled = false;
                syncIcon.style.display = 'inline';
                syncText.textContent = 'Обновить';
                syncSpinner.style.display = 'none';
            });
        }
        
        function loadLimits() {
            fetch('/api/football/limits')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.limits) {
                        const limits = data.limits;
                        
                        // Осталось запросов
                        const remainingEl = document.getElementById('limit-remaining');
                        if (limits.requests_remaining !== null && limits.requests_remaining !== undefined) {
                            remainingEl.textContent = limits.requests_remaining;
                            
                            // Цвет в зависимости от количества (только для критических/предупреждающих значений)
                            remainingEl.className = 'limit-value';
                            if (limits.requests_remaining < 50) {
                                remainingEl.classList.add('limit-critical');
                            } else if (limits.requests_remaining < 100) {
                                remainingEl.classList.add('limit-warning');
                            }
                            // Для >= 100 оставляем белый цвет (по умолчанию)
                        } else {
                            remainingEl.textContent = 'N/A';
                            remainingEl.className = 'limit-value';
                        }
                        
                        // Использовано
                        const usedEl = document.getElementById('limit-used');
                        if (limits.requests_used !== null && limits.requests_used !== undefined) {
                            usedEl.textContent = limits.requests_used;
                            usedEl.className = 'limit-value';
                        } else {
                            usedEl.textContent = 'N/A';
                            usedEl.className = 'limit-value';
                        }
                        
                        // Стоимость последнего запроса
                        const costEl = document.getElementById('limit-cost');
                        if (limits.requests_last_cost !== null && limits.requests_last_cost !== undefined) {
                            costEl.textContent = limits.requests_last_cost;
                            costEl.className = 'limit-value';
                        } else {
                            costEl.textContent = 'N/A';
                            costEl.className = 'limit-value';
                        }
                    }
                })
                .catch(error => {
                    console.error('Error loading API limits:', error);
                    document.getElementById('limit-remaining').textContent = 'Ошибка';
                    document.getElementById('limit-used').textContent = 'Ошибка';
                    document.getElementById('limit-cost').textContent = 'Ошибка';
                });
        }
        
        function loadMatches() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('matches-container').style.display = 'none';
            
            // Загружаем обе таблицы параллельно
            Promise.all([
                fetch('/api/football/matches').then(r => r.json()),
                fetch('/api/football/matches/all').then(r => r.json())
            ])
                .then(([favData, allData]) => {
                    document.getElementById('loading').style.display = 'none';
                    
                    // Обрабатываем матчи с фаворитом
                    if (favData.success && favData.matches && favData.matches.length > 0) {
                        allMatches = favData.matches;
                        document.getElementById('matches-container').style.display = 'block';
                        document.getElementById('empty-state').style.display = 'none';
                        
                        // Применяем фильтр и сортировку
                        const filtered = filterMatchesByDate(allMatches, currentDateFilterFav, dateRangeFav);
                        if (!currentSortField) {
                            currentSortField = 'match_date';
                            currentSortDirection = 'desc';
                        }
                        sortTable(currentSortField, filtered);
                    } else {
                        allMatches = [];
                        document.getElementById('empty-state').style.display = 'block';
                    }
                    
                    // Обрабатываем все матчи
                    if (allData.success && allData.matches && allData.matches.length > 0) {
                        allMatchesData = allData.matches;
                        // Применяем фильтр и сортировку
                        const filtered = filterMatchesByDate(allMatchesData, currentDateFilterAll, dateRangeAll);
                        // Сортировка по умолчанию: дата и время (по убыванию)
                        if (!currentSortFieldAll) {
                            currentSortFieldAll = 'match_date';
                            currentSortDirectionAll = 'desc';
                        }
                        sortTableAll(currentSortFieldAll, filtered);
                    } else {
                        allMatchesData = [];
                        document.getElementById('all-matches-empty-state').style.display = 'block';
                        document.getElementById('all-matches-container').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Error loading matches:', error);
                    document.getElementById('loading').style.display = 'none';
                    allMatches = [];
                    allMatchesData = [];
                    document.getElementById('empty-state').style.display = 'block';
                    document.getElementById('all-matches-empty-state').style.display = 'block';
                });
        }

                 function calculateTotals(matches) {
             let sumK0 = 0;
             let sumK1 = 0;
             let sumK60 = 0;
             let sumBet = 0;
             let sumBetAI = 0;
             
             matches.forEach(match => {
                 // Пропускаем незавершенные матчи
                 if (match.status !== 'finished') {
                     return;
                 }
                 
                 // Если фаворит выиграл (fav_won === 1): прибыль = коэффициент - 1 (получаем коэффициент, но вложили 1)
                 // Если проиграл или ничья (fav_won !== 1): прибыль = -1 (теряем ставку)
                 // Считаем только если есть коэффициент (ставка была сделана)
                 
                 // K0 - ставка на фаворита после открытия линии (initial_odds)
                 if (match.initial_odds && !isNaN(parseFloat(match.initial_odds))) {
                     if (match.fav_won === 1) {
                         sumK0 += parseFloat(match.initial_odds) - 1;
                     } else {
                         sumK0 -= 1;
                     }
                 }
                 
                 // K1 - ставка на фаворита в день матча (last_odds)
                 if (match.last_odds && !isNaN(parseFloat(match.last_odds))) {
                     if (match.fav_won === 1) {
                         sumK1 += parseFloat(match.last_odds) - 1;
                     } else {
                         sumK1 -= 1;
                     }
                 }
                 
                 // K60 - ставка на фаворита в перерыве (live_odds)
                 if (match.live_odds && !isNaN(parseFloat(match.live_odds))) {
                     if (match.fav_won === 1) {
                         sumK60 += parseFloat(match.live_odds) - 1;
                     } else {
                         sumK60 -= 1;
                     }
                 }
                 
                 // Bet - ставка на фаворита в перерыве только если рекомендовано ИИ (bet >= 1), используем K60 (live_odds)
                 const betValue = match.bet ? parseFloat(match.bet) : 0;
                 if (betValue >= 1 && match.live_odds && !isNaN(parseFloat(match.live_odds))) {
                     if (match.fav_won === 1) {
                         // Фаворит выиграл - добавляем чистую прибыль от live_odds
                         sumBet += parseFloat(match.live_odds) - 1;
                     } else {
                         // Фаворит проиграл или ничья - вычитаем ставку (1)
                         sumBet -= 1;
                     }
                 }
                 
                 // Прогноз ИИ - ставка на прогнозированный исход ИИ (bet_ai_odds)
                 if (match.bet_ai && match.bet_ai_odds && !isNaN(parseFloat(match.bet_ai_odds))) {
                     // Определяем фактический результат матча
                     const homeScore = match.final_score_home !== null && match.final_score_home !== undefined ? parseInt(match.final_score_home) : null;
                     const awayScore = match.final_score_away !== null && match.final_score_away !== undefined ? parseInt(match.final_score_away) : null;
                     
                     if (homeScore !== null && awayScore !== null) {
                         let actualResult = null;
                         if (homeScore > awayScore) {
                             actualResult = '1';
                         } else if (homeScore === awayScore) {
                             actualResult = 'X';
                         } else {
                             actualResult = '2';
                         }
                         
                         // Проверяем, совпал ли прогноз ИИ с фактическим результатом
                         const betAIUpper = match.bet_ai.toUpperCase();
                         let isWin = false;
                         
                         if (betAIUpper === actualResult) {
                             // Одиночный исход совпал
                             isWin = true;
                         } else if (betAIUpper === '1X' && (actualResult === '1' || actualResult === 'X')) {
                             // Двойной шанс 1X выиграл
                             isWin = true;
                         } else if (betAIUpper === 'X2' && (actualResult === 'X' || actualResult === '2')) {
                             // Двойной шанс X2 выиграл
                             isWin = true;
                         }
                         
                         if (isWin) {
                             // Прогноз ИИ совпал - добавляем чистую прибыль
                             sumBetAI += parseFloat(match.bet_ai_odds) - 1;
                         } else {
                             // Прогноз ИИ не совпал - вычитаем ставку (1)
                             sumBetAI -= 1;
                         }
                     }
                 }
             });
             
            // Обновляем строку итогов
            const totalsRow = document.getElementById('totals-row');
            const totalK0El = document.getElementById('total-k0');
            const totalK1El = document.getElementById('total-k1');
            const totalK60El = document.getElementById('total-k60');
            const totalBetEl = document.getElementById('total-bet');
            const totalBetAIEl = document.getElementById('total-bet-ai');
            
            if (totalsRow && totalK0El && totalK1El && totalK60El && totalBetEl && totalBetAIEl) {
                totalK0El.textContent = sumK0.toFixed(2);
                totalK1El.textContent = sumK1.toFixed(2);
                totalK60El.textContent = sumK60.toFixed(2);
                totalBetEl.textContent = sumBet.toFixed(2);
                totalBetAIEl.textContent = sumBetAI.toFixed(2);
                
                // Показываем строку итогов только если есть завершенные матчи
                const finishedMatches = matches.filter(m => m.status === 'finished');
                if (finishedMatches.length > 0) {
                    totalsRow.style.display = '';
                } else {
                    totalsRow.style.display = 'none';
                }
            }
        }

        function extractStatValue(stats, statGroupName, statItemName) {
            // Функция для извлечения значения из элемента статистики
            const getValue = (item) => {
                // Используем homeValue/awayValue если они есть (числовые значения)
                if (item.homeValue !== undefined && item.awayValue !== undefined) {
                    return {
                        home: item.homeValue,
                        away: item.awayValue
                    };
                }
                // Иначе пытаемся парсить из строк home/away (могут быть "70%" или "10")
                const parseValue = (str) => {
                    if (!str) return 0;
                    const num = parseFloat(str.toString().replace('%', '').trim());
                    return isNaN(num) ? 0 : num;
                };
                return {
                    home: parseValue(item.home),
                    away: parseValue(item.away)
                };
            };
            
            // Пытаемся найти в raw_data.statistics (приоритет - там данные для периода "ALL")
            if (stats.raw_data && stats.raw_data.statistics && Array.isArray(stats.raw_data.statistics)) {
                for (const statPeriod of stats.raw_data.statistics) {
                    // Ищем период "ALL" (общая статистика матча)
                    if (statPeriod.period === 'ALL' && statPeriod.groups && Array.isArray(statPeriod.groups)) {
                        for (const group of statPeriod.groups) {
                            if (group.groupName === statGroupName && group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                for (const item of group.statisticsItems) {
                                    if (item.name === statItemName) {
                                        return getValue(item);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Пытаемся найти в statistics (верхний уровень)
            if (stats.statistics && Array.isArray(stats.statistics)) {
                for (const statPeriod of stats.statistics) {
                    if (statPeriod.period === 'ALL' && statPeriod.groups && Array.isArray(statPeriod.groups)) {
                        for (const group of statPeriod.groups) {
                            if (group.groupName === statGroupName && group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                for (const item of group.statisticsItems) {
                                    if (item.name === statItemName) {
                                        return getValue(item);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Пытаемся найти в periods (старый формат)
            if (stats.periods && Array.isArray(stats.periods)) {
                for (const period of stats.periods) {
                    if ((period.period === 'all' || period.period === 'REGULAR' || period.period === 'ALL') && period.groups && Array.isArray(period.groups)) {
                        for (const group of period.groups) {
                            if (group.groupName === statGroupName && group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                for (const item of group.statisticsItems) {
                                    if (item.name === statItemName) {
                                        return getValue(item);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Пытаемся найти в raw_data.periods (старый формат)
            if (stats.raw_data && stats.raw_data.periods && Array.isArray(stats.raw_data.periods)) {
                for (const period of stats.raw_data.periods) {
                    if ((period.period === 'all' || period.period === 'REGULAR' || period.period === 'ALL') && period.groups && Array.isArray(period.groups)) {
                        for (const group of period.groups) {
                            if (group.groupName === statGroupName && group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                for (const item of group.statisticsItems) {
                                    if (item.name === statItemName) {
                                        return getValue(item);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            return null;
        }
        
        function formatStats(statsJson) {
            if (!statsJson) return null;
            
            try {
                const stats = typeof statsJson === 'string' ? JSON.parse(statsJson) : statsJson;
                if (!stats || typeof stats !== 'object') return null;
                
                let formatted = [];
                
                // Счет
                if (stats.score) {
                    formatted.push(`Счет: ${stats.score.home || 0} - ${stats.score.away || 0}`);
                }
                
                // Владение мячом - в группе "Match overview"
                let possession = extractStatValue(stats, 'Match overview', 'Ball possession');
                if (possession) {
                    formatted.push(`Владение: ${possession.home || 0}% - ${possession.away || 0}%`);
                }
                
                // Удары в створ - в группе "Shots"
                let shotsOnTarget = extractStatValue(stats, 'Shots', 'Shots on target');
                if (shotsOnTarget) {
                    formatted.push(`Удары в створ: ${shotsOnTarget.home || 0} - ${shotsOnTarget.away || 0}`);
                }
                
                // xG - в группе "Match overview"
                let xg = extractStatValue(stats, 'Match overview', 'Expected goals');
                if (xg) {
                    formatted.push(`xG: ${(xg.home || 0).toFixed(2)} - ${(xg.away || 0).toFixed(2)}`);
                }
                
                // Общие удары - в группе "Shots" или "Match overview"
                let shots = extractStatValue(stats, 'Shots', 'Total shots');
                if (!shots) {
                    shots = extractStatValue(stats, 'Match overview', 'Total shots');
                }
                if (shots) {
                    formatted.push(`Всего ударов: ${shots.home || 0} - ${shots.away || 0}`);
                }
                
                // Угловые - в группе "Match overview"
                let corners = extractStatValue(stats, 'Match overview', 'Corner kicks');
                if (corners) {
                    formatted.push(`Угловые: ${corners.home || 0} - ${corners.away || 0}`);
                }
                
                // Желтые карточки - в группе "Match overview"
                let yellowCards = extractStatValue(stats, 'Match overview', 'Yellow cards');
                if (yellowCards) {
                    formatted.push(`Желтые карточки: ${yellowCards.home || 0} - ${yellowCards.away || 0}`);
                }
                
                // Фолы - в группе "Match overview"
                let fouls = extractStatValue(stats, 'Match overview', 'Fouls');
                if (fouls) {
                    formatted.push(`Фолы: ${fouls.home || 0} - ${fouls.away || 0}`);
                }
                
                // Если ничего не нашлось, показываем структуру для отладки
                if (formatted.length === 1 && formatted[0].startsWith('Счет:')) {
                    console.warn('Найдена только статистика счета. Структура данных:', stats);
                    // Пробуем показать все доступные группы статистики
                    let debugInfo = ['=== Отладка структуры ==='];
                    if (stats.periods && Array.isArray(stats.periods)) {
                        stats.periods.forEach((period, idx) => {
                            if (period.groups && Array.isArray(period.groups)) {
                                period.groups.forEach(group => {
                                    debugInfo.push(`Период ${idx}, Группа: ${group.groupName || 'N/A'}`);
                                    if (group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                        group.statisticsItems.forEach(item => {
                                            debugInfo.push(`  - ${item.name || 'N/A'}: ${item.home || 0} - ${item.away || 0}`);
                                        });
                                    }
                                });
                            }
                        });
                    }
                    if (stats.statistics && Array.isArray(stats.statistics)) {
                        stats.statistics.forEach(group => {
                            debugInfo.push(`Группа: ${group.groupName || 'N/A'}`);
                            if (group.statisticsItems && Array.isArray(group.statisticsItems)) {
                                group.statisticsItems.forEach(item => {
                                    debugInfo.push(`  - ${item.name || 'N/A'}: ${item.home || 0} - ${item.away || 0}`);
                                });
                            }
                        });
                    }
                    console.log(debugInfo.join('\n'));
                    
                    // Добавляем упрощенную структуру в tooltip
                    if (debugInfo.length > 1) {
                        formatted.push('\n' + debugInfo.slice(1).join('\n'));
                    }
                }
                
                return formatted.length > 0 ? formatted.join('\n') : null;
            } catch (e) {
                console.error('Ошибка парсинга статистики:', e);
                console.error('Данные статистики:', statsJson);
                return null;
            }
        }
        
        function displayMatches(matches) {
            const tbody = document.getElementById('matches-table-body');
            tbody.innerHTML = '';
            
            if (!matches || matches.length === 0) {
                // Если нет матчей, показываем пустую таблицу (состояние пустоты обрабатывается отдельно)
                document.getElementById('matches-container').style.display = 'none';
                document.getElementById('empty-state').style.display = 'block';
                // Скрываем строку итогов
                const totalsRow = document.getElementById('totals-row');
                if (totalsRow) {
                    totalsRow.style.display = 'none';
                }
                return;
            }
            
            document.getElementById('matches-container').style.display = 'block';
            document.getElementById('empty-state').style.display = 'none';
            
            matches.forEach(match => {
                const row = document.createElement('tr');
                
                const statusBadgeClass = `status-${match.status}`;
                const statusText = {
                    'scheduled': 'Запланирован',
                    'in_progress': 'Идет',
                    'finished': 'Завершен'
                }[match.status] || match.status;
                
                // Делаем статус "Идет" кликабельным, если есть sofascore_event_id
                let statusHtml = `<span class="status-badge ${statusBadgeClass}">${statusText}</span>`;
                if (match.status === 'in_progress' && match.sofascore_event_id) {
                    statusHtml = `<span class="status-badge ${statusBadgeClass} sofascore-status-clickable" 
                                        style="cursor: pointer; text-decoration: underline;" 
                                        data-sofascore-id="${match.sofascore_event_id}"
                                        data-home-team="${match.home_team}"
                                        data-away-team="${match.away_team}"
                                        title="Нажмите для просмотра матча в прямом эфире">${statusText}</span>`;
                }
                
                const finalScore = match.final_score_home !== null && match.final_score_away !== null
                    ? `${match.final_score_home}-${match.final_score_away}`
                    : '-';
                
                // Функция для форматирования коэффициентов (округление до сотых)
                const formatOdds = (odds) => {
                    if (odds === null || odds === undefined || odds === '') {
                        return '-';
                    }
                    const num = parseFloat(odds);
                    if (isNaN(num)) {
                        return '-';
                    }
                    return num.toFixed(2);
                };
                
                // Определяем класс для подсветки итогового счета в зависимости от результата фаворита
                let finalScoreHtml = finalScore;
                if (match.status === 'finished' && match.final_score_home !== null && match.final_score_away !== null) {
                    const homeScore = parseInt(match.final_score_home);
                    const awayScore = parseInt(match.final_score_away);
                    const isDraw = homeScore === awayScore;
                    
                    let finalScoreClass = '';
                    if (isDraw) {
                        // Ничья - желтый
                        finalScoreClass = 'final-score-draw';
                    } else if (match.fav_won === 1) {
                        // Фаворит выиграл - зеленый
                        finalScoreClass = 'final-score-win';
                    } else {
                        // Фаворит проиграл - красный
                        finalScoreClass = 'final-score-loss';
                    }
                    
                    if (finalScoreClass) {
                        finalScoreHtml = `<span class="${finalScoreClass}">${finalScore}</span>`;
                    }
                }
                
                                 // Формируем ячейку K60 с tooltip
                 let k60Cell = '';
                 const statsFormatted = formatStats(match.stats_60min);
                 const hasLiveOdds = match.live_odds !== null && match.live_odds !== undefined;
                 const formattedLiveOdds = formatOdds(match.live_odds);
                 
                 if (statsFormatted) {
                     // Есть статистика - показываем tooltip
                     if (hasLiveOdds) {
                         // Есть и коэффициент, и статистика
                         k60Cell = `
                             <span class="stats-tooltip" data-tooltip-position="">
                                 <span class="odds">${formattedLiveOdds}</span>
                                 <span class="tooltip-content">${statsFormatted.replace(/\n/g, '<br>')}</span>
                             </span>
                         `;
                     } else {
                         // Нет коэффициента, но есть статистика - показываем иконку информации
                         k60Cell = `
                             <span class="stats-tooltip" data-tooltip-position="">
                                 <i class="fas fa-info-circle info-icon"></i>
                                 <span class="tooltip-content">${statsFormatted.replace(/\n/g, '<br>')}</span>
                             </span>
                         `;
                     }
                 } else {
                     // Нет статистики - просто показываем коэффициент или "-"
                     k60Cell = `<span class="odds">${formattedLiveOdds}</span>`;
                 }
                 
                row.innerHTML = `
                    <td>${match.match_date}</td>
                    <td>${match.match_time}</td>
                    <td>${match.home_team}</td>
                    <td>${match.away_team}</td>
                    <td><span class="fav-team">${match.fav}</span></td>
                    <td><span class="odds">${formatOdds(match.initial_odds)}</span></td>
                    <td><span class="odds">${formatOdds(match.last_odds)}</span></td>
                    <td>${k60Cell}</td>
                    <td>${match.bet_ai ? (match.bet_ai_odds ? `<span class="odds">${match.bet_ai} <small>(${formatOdds(match.bet_ai_odds)})</small></span>` : match.bet_ai) : '-'}</td>
                    <td>${(match.bet && parseFloat(match.bet) >= 1) ? '<i class="fas fa-check text-success"></i>' : ''}</td>
                    <td>${finalScoreHtml}</td>
                    <td>${statusHtml}</td>
                `;
                
                                 tbody.appendChild(row);
             });
             
             // Рассчитываем и отображаем итоги
             calculateTotals(matches);
             
             // Настраиваем позицию tooltip'ов после добавления строк в DOM
             setTimeout(() => {
                 adjustTooltipPositions();
                 // Добавляем обработчики клика на статус "Идет" для первой таблицы
                 setupSofascoreStatusHandlers();
             }, 0);
         }
         
         function displayAllMatches(matches) {
             const tbody = document.getElementById('all-matches-table-body');
             tbody.innerHTML = '';
             
             if (!matches || matches.length === 0) {
                 document.getElementById('all-matches-empty-state').style.display = 'block';
                 document.getElementById('all-matches-container').style.display = 'none';
                 return;
             }
             
             document.getElementById('all-matches-container').style.display = 'block';
             document.getElementById('all-matches-empty-state').style.display = 'none';
             
             // Сохраняем матчи в глобальную переменную для доступа из обработчиков
             window.allMatchesForRisk = matches;
             
             // Функция для форматирования коэффициентов
             const formatOdds = (odds) => {
                 if (odds === null || odds === undefined || odds === '') {
                     return '-';
                 }
                 const num = parseFloat(odds);
                 if (isNaN(num)) {
                     return '-';
                 }
                 return num.toFixed(2);
             };
             
             matches.forEach((match, index) => {
                 const row = document.createElement('tr');
                 
                // Проверяем, что разница между коэффициентами на победу обеих команд не более 0.2
                const odds1 = match.live_odds_1 !== null && match.live_odds_1 !== undefined ? parseFloat(match.live_odds_1) : NaN;
                const odds2 = match.live_odds_2 !== null && match.live_odds_2 !== undefined ? parseFloat(match.live_odds_2) : NaN;
                const isBalancedOdds = !isNaN(odds1) && !isNaN(odds2) && 
                                      Math.abs(odds1 - odds2) <= 0.2;
                
                // Проверяем, есть ли фаворит (коэффициент < 1.30) - проверяем ТЕКУЩИЕ коэффициенты
                const hasFavorite = (!isNaN(odds1) && odds1 < 1.30) || 
                                   (!isNaN(odds2) && odds2 < 1.30);
                
                // Проверяем, был ли фаворит изначально, но коэффициент вырос >= 1.30
                const hadFavoriteButDeclined = (match.fav && match.fav !== 'NONE') && 
                                             !hasFavorite; // Был фаворит, но сейчас нет
                
                if (isBalancedOdds) {
                    row.classList.add('match-balanced-odds');
                    console.log(`Подсвечен матч: ${match.home_team} vs ${match.away_team}, кэфы: ${odds1}, ${odds2}, разница: ${Math.abs(odds1 - odds2).toFixed(2)}`);
                }
                
                if (hasFavorite) {
                    row.classList.add('match-with-favorite');
                } else if (hadFavoriteButDeclined) {
                    row.classList.add('match-favorite-declined');
                }
                 
                 const statusBadgeClass = `status-${match.status}`;
                 const statusText = {
                     'scheduled': 'Запланирован',
                     'in_progress': 'Идет',
                     'finished': 'Завершен'
                 }[match.status] || match.status;
                 
                 // Делаем статус "Идет" кликабельным, если есть sofascore_event_id
                 let statusHtml = `<span class="status-badge ${statusBadgeClass}">${statusText}</span>`;
                 if (match.status === 'in_progress' && match.sofascore_event_id) {
                     statusHtml = `<span class="status-badge ${statusBadgeClass} sofascore-status-clickable" 
                                         style="cursor: pointer; text-decoration: underline;" 
                                         data-sofascore-id="${match.sofascore_event_id}"
                                         data-home-team="${match.home_team}"
                                         data-away-team="${match.away_team}"
                                         title="Нажмите для просмотра матча в прямом эфире">${statusText}</span>`;
                 }
                 
                const finalScore = match.final_score_home !== null && match.final_score_away !== null
                    ? `${match.final_score_home}-${match.final_score_away}`
                    : '-';
                
                // Формируем ячейку прогноза ИИ с tooltip и подсветкой
                let betAICell = '';
                const statsFormatted = formatStats(match.stats_60min);
                const hasBetAI = match.bet_ai && match.bet_ai !== null && match.bet_ai !== undefined;
                
                // Определяем фактический результат для подсветки
                let betAIClass = '';
                if (hasBetAI && match.status === 'finished' && match.final_score_home !== null && match.final_score_away !== null) {
                    const homeScore = parseInt(match.final_score_home);
                    const awayScore = parseInt(match.final_score_away);
                    const isDraw = homeScore === awayScore;
                    const homeWon = homeScore > awayScore;
                    const awayWon = awayScore > homeScore;
                    
                    const betAIUpper = match.bet_ai.toUpperCase();
                    let isCorrect = false;
                    
                    if (isDraw) {
                        // Ничья - правильные прогнозы: X, 1X, X2
                        if (betAIUpper === 'X' || betAIUpper === '1X' || betAIUpper === 'X2') {
                            isCorrect = true;
                            betAIClass = 'final-score-draw'; // Желтый для ничьей
                        }
                    } else if (homeWon) {
                        // Домашняя команда выиграла - правильные прогнозы: 1, 1X
                        if (betAIUpper === '1' || betAIUpper === '1X') {
                            isCorrect = true;
                            betAIClass = 'final-score-win'; // Зеленый для победы
                        }
                    } else if (awayWon) {
                        // Гостевая команда выиграла - правильные прогнозы: 2, X2
                        if (betAIUpper === '2' || betAIUpper === 'X2') {
                            isCorrect = true;
                            betAIClass = 'final-score-win'; // Зеленый для победы
                        }
                    }
                    
                    // Если прогноз неверный - красный
                    if (!isCorrect) {
                        betAIClass = 'final-score-loss';
                    }
                }
                
                if (hasBetAI) {
                    const betAIContent = betAIClass ? `<span class="${betAIClass}">${match.bet_ai}</span>` : match.bet_ai;
                    
                    // Делаем прогноз кликабельным для анализа риска
                    const betAIWithClick = `<span class="bet-ai-clickable" data-match-index="${index}" style="cursor: pointer; text-decoration: underline;" title="Нажмите для анализа риска">${betAIContent}</span>`;
                    
                    if (statsFormatted) {
                        // Есть статистика - показываем tooltip
                        betAICell = `
                            <span class="stats-tooltip" data-tooltip-position="">
                                ${betAIWithClick}
                                <span class="tooltip-content">${statsFormatted.replace(/\n/g, '<br>')}</span>
                            </span>
                        `;
                    } else {
                        // Нет статистики - просто показываем прогноз
                        betAICell = betAIWithClick;
                    }
                } else {
                    betAICell = '-';
                }
                
                row.innerHTML = `
                    <td>${match.match_date}</td>
                    <td>${match.match_time}</td>
                    <td>${match.home_team}</td>
                    <td>${match.away_team}</td>
                    <td><span class="odds">${formatOdds(match.live_odds_1)}</span></td>
                    <td><span class="odds">${formatOdds(match.live_odds_x)}</span></td>
                    <td><span class="odds">${formatOdds(match.live_odds_2)}</span></td>
                    <td>${betAICell}</td>
                    <td>${(match.bet && parseFloat(match.bet) >= 1) ? '<i class="fas fa-check text-success"></i>' : ''}</td>
                    <td>${finalScore}</td>
                    <td>${statusHtml}</td>
                `;
                
                // Повторно применяем классы после установки innerHTML (на случай если они были сброшены)
                if (isBalancedOdds) {
                    row.classList.add('match-balanced-odds');
                }
                if (hasFavorite) {
                    row.classList.add('match-with-favorite');
                } else if (hadFavoriteButDeclined) {
                    row.classList.add('match-favorite-declined');
                }
                
                tbody.appendChild(row);
            });
            
            // Рассчитываем и отображаем итоги для прогноза ИИ
            calculateTotalsAllMatches(matches);
            
            // Настраиваем позицию tooltip'ов после добавления строк в DOM
            setTimeout(() => {
                adjustTooltipPositions();
                // Добавляем обработчики клика на прогнозы ИИ после отображения таблицы
                setupBetAIClickHandlers();
                // Добавляем обработчики клика на статус "Идет" для открытия виджета SofaScore
                setupSofascoreStatusHandlers();
            }, 0);
        }
        
        // Функция для настройки обработчиков клика на статус "Идет"
        function setupSofascoreStatusHandlers() {
            // Используем делегирование событий для динамически созданных элементов
            document.querySelectorAll('.sofascore-status-clickable').forEach(clickable => {
                clickable.addEventListener('click', function(e) {
                    e.preventDefault();
                    const sofascoreId = this.getAttribute('data-sofascore-id');
                    const homeTeam = this.getAttribute('data-home-team');
                    const awayTeam = this.getAttribute('data-away-team');
                    
                    if (sofascoreId) {
                        showSofascoreWidget(sofascoreId, homeTeam, awayTeam);
                    }
                });
            });
        }
        
        // Функция для отображения виджета SofaScore
        function showSofascoreWidget(sofascoreId, homeTeam, awayTeam) {
            const modalElement = document.getElementById('sofascoreModal');
            const modal = new bootstrap.Modal(modalElement);
            const content = document.getElementById('sofascoreWidgetContainer');
            
            // Обновляем заголовок модального окна
            document.getElementById('sofascoreModalLabel').textContent = `${homeTeam} vs ${awayTeam}`;
            
            // Формируем HTML с виджетом
            // Нормализуем названия команд для URL (упрощенная версия)
            const normalizeForUrl = (str) => {
                return str.toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace(/[^a-z0-9-]/g, '')
                    .replace(/-+/g, '-')
                    .replace(/^-|-$/g, '');
            };
            
            const homeTeamUrl = normalizeForUrl(homeTeam);
            const awayTeamUrl = normalizeForUrl(awayTeam);
            
            const widgetHtml = `
                <iframe width="100%" height="286" 
                        src="https://widgets.sofascore.com/embed/attackMomentum?id=${sofascoreId}&widgetTheme=light" 
                        frameborder="0" 
                        scrolling="no"
                        style="min-height: 286px;">
                </iframe>
                <div style="font-size:12px;font-family:Arial,sans-serif;margin-top:10px;">
                    <a href="https://www.sofascore.com/football/match/${homeTeamUrl}-${awayTeamUrl}/lOsHOi#id:${sofascoreId}" 
                       target="_blank" 
                       rel="noreferrer">
                        ${homeTeam} - ${awayTeam} Live Score
                    </a>
                </div>
            `;
            
            content.innerHTML = widgetHtml;
            modal.show();
        }
        
        function setupBetAIClickHandlers() {
            // Используем делегирование событий для динамически созданных элементов
            document.querySelectorAll('.bet-ai-clickable').forEach(clickable => {
                clickable.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    const matchIndex = parseInt(this.getAttribute('data-match-index'));
                    if (window.allMatchesForRisk && matchIndex >= 0 && matchIndex < window.allMatchesForRisk.length) {
                        const match = window.allMatchesForRisk[matchIndex];
                        if (match.fixture_id && match.bet_ai && match.bet_ai_odds && match.stats_60min) {
                            // Преобразуем stats_60min в JSON строку, если это объект
                            const statsJson = typeof match.stats_60min === 'string' 
                                ? match.stats_60min 
                                : JSON.stringify(match.stats_60min);
                            showRiskAnalysis(match.fixture_id, match.bet_ai, parseFloat(match.bet_ai_odds), statsJson);
                        }
                    }
                });
            });
        }
        
        function showRiskAnalysis(fixtureId, betAI, betAIOdds, statsJson) {
            const modalElement = document.getElementById('riskAnalysisModal');
            const modal = new bootstrap.Modal(modalElement);
            const content = document.getElementById('riskAnalysisContent');
            
            // Показываем модальное окно с индикатором загрузки
            content.innerHTML = `
                <div class="text-center">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Загрузка анализа...</span>
                    </div>
                    <p class="mt-2">Запрос анализа риска...</p>
                </div>
            `;
            modal.show();
            
            // Отправляем запрос к API
            fetch('/api/football/analyze-risk', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    fixture_id: fixtureId,
                    bet_ai: betAI,
                    bet_ai_odds: betAIOdds,
                    stats_json: statsJson
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success && data.analysis) {
                    // Рендерим markdown в HTML
                    const markdownHtml = marked.parse(data.analysis);
                    
                    // Отображаем анализ с markdown форматированием
                    content.innerHTML = `
                        <div class="risk-analysis-result">
                            <h6>Прогноз ИИ: <strong>${betAI}</strong> (коэффициент: ${betAIOdds.toFixed(2)})</h6>
                            <hr>
                            <div class="analysis-text" style="line-height: 1.6;">${markdownHtml}</div>
                        </div>
                    `;
                } else {
                    content.innerHTML = `
                        <div class="alert alert-danger">
                            <strong>Ошибка:</strong> ${data.error || 'Не удалось получить анализ риска'}
                        </div>
                    `;
                }
            })
            .catch(error => {
                console.error('Ошибка запроса анализа риска:', error);
                content.innerHTML = `
                    <div class="alert alert-danger">
                        <strong>Ошибка:</strong> Не удалось выполнить запрос анализа риска
                    </div>
                `;
            });
        }
        
        function calculateTotalsAllMatches(matches) {
            let sumBetAI = 0;
            let sumBet = 0;
            
            matches.forEach(match => {
                // Пропускаем незавершенные матчи
                if (match.status !== 'finished') {
                    return;
                }
                
                // Bet - ставка на прогноз ИИ только если рекомендовано (bet >= 1), используем bet_ai_odds
                const betValue = match.bet ? parseFloat(match.bet) : 0;
                if (betValue >= 1 && match.bet_ai && match.bet_ai_odds && !isNaN(parseFloat(match.bet_ai_odds))) {
                    // Определяем фактический результат матча
                    const homeScore = match.final_score_home !== null && match.final_score_home !== undefined ? parseInt(match.final_score_home) : null;
                    const awayScore = match.final_score_away !== null && match.final_score_away !== undefined ? parseInt(match.final_score_away) : null;
                    
                    if (homeScore !== null && awayScore !== null) {
                        let actualResult = null;
                        if (homeScore > awayScore) {
                            actualResult = '1';
                        } else if (homeScore === awayScore) {
                            actualResult = 'X';
                        } else {
                            actualResult = '2';
                        }
                        
                        // Проверяем, совпал ли прогноз ИИ с фактическим результатом
                        const betAIUpper = match.bet_ai.toUpperCase();
                        let isWin = false;
                        
                        if (betAIUpper === actualResult) {
                            // Одиночный исход совпал
                            isWin = true;
                        } else if (betAIUpper === '1X' && (actualResult === '1' || actualResult === 'X')) {
                            // Двойной шанс 1X выиграл
                            isWin = true;
                        } else if (betAIUpper === 'X2' && (actualResult === 'X' || actualResult === '2')) {
                            // Двойной шанс X2 выиграл
                            isWin = true;
                        }
                        
                        if (isWin) {
                            // Прогноз ИИ совпал - добавляем чистую прибыль
                            sumBet += parseFloat(match.bet_ai_odds) - 1;
                        } else {
                            // Прогноз ИИ не совпал - вычитаем ставку (1)
                            sumBet -= 1;
                        }
                    }
                }
                
                // Прогноз ИИ - ставка на прогнозированный исход ИИ (bet_ai_odds) - считаем для всех
                if (match.bet_ai && match.bet_ai_odds && !isNaN(parseFloat(match.bet_ai_odds))) {
                    // Определяем фактический результат матча
                    const homeScore = match.final_score_home !== null && match.final_score_home !== undefined ? parseInt(match.final_score_home) : null;
                    const awayScore = match.final_score_away !== null && match.final_score_away !== undefined ? parseInt(match.final_score_away) : null;
                    
                    if (homeScore !== null && awayScore !== null) {
                        let actualResult = null;
                        if (homeScore > awayScore) {
                            actualResult = '1';
                        } else if (homeScore === awayScore) {
                            actualResult = 'X';
                        } else {
                            actualResult = '2';
                        }
                        
                        // Проверяем, совпал ли прогноз ИИ с фактическим результатом
                        const betAIUpper = match.bet_ai.toUpperCase();
                        let isWin = false;
                        
                        if (betAIUpper === actualResult) {
                            // Одиночный исход совпал
                            isWin = true;
                        } else if (betAIUpper === '1X' && (actualResult === '1' || actualResult === 'X')) {
                            // Двойной шанс 1X выиграл
                            isWin = true;
                        } else if (betAIUpper === 'X2' && (actualResult === 'X' || actualResult === '2')) {
                            // Двойной шанс X2 выиграл
                            isWin = true;
                        }
                        
                        if (isWin) {
                            // Прогноз ИИ совпал - добавляем чистую прибыль
                            sumBetAI += parseFloat(match.bet_ai_odds) - 1;
                        } else {
                            // Прогноз ИИ не совпал - вычитаем ставку (1)
                            sumBetAI -= 1;
                        }
                    }
                }
            });
            
            // Обновляем строку итогов
            const totalsRow = document.getElementById('totals-row-all');
            const totalBetAIEl = document.getElementById('total-bet-ai-all');
            const totalBetEl = document.getElementById('total-bet-all');
            
            if (totalsRow && totalBetAIEl && totalBetEl) {
                totalBetAIEl.textContent = sumBetAI.toFixed(2);
                totalBetEl.textContent = sumBet.toFixed(2);
                
                // Показываем строку итогов только если есть завершенные матчи
                const finishedMatches = matches.filter(m => m.status === 'finished');
                if (finishedMatches.length > 0) {
                    totalsRow.style.display = '';
                } else {
                    totalsRow.style.display = 'none';
                }
            }
        }
         
         function updateTooltipPosition(tooltip) {
             const tooltipContent = tooltip.querySelector('.tooltip-content');
             if (!tooltipContent) return;
             
             const rect = tooltip.getBoundingClientRect();
             const tooltipHeight = 250; // Примерная высота tooltip
             const spaceAbove = rect.top;
             const spaceBelow = window.innerHeight - rect.bottom;
             
             // Определяем, где больше места
             if (spaceAbove < tooltipHeight && spaceBelow >= tooltipHeight) {
                 // Показываем снизу
                 tooltip.classList.add('tooltip-bottom');
                 tooltipContent.style.top = (rect.bottom + 10) + 'px';
                 tooltipContent.style.left = (rect.left + rect.width / 2) + 'px';
                 tooltipContent.style.bottom = 'auto';
                 tooltipContent.style.right = 'auto';
                 tooltipContent.style.transform = 'translateX(-50%)';
             } else {
                 // Показываем сверху (по умолчанию)
                 tooltip.classList.remove('tooltip-bottom');
                 const topPos = Math.max(10, rect.top - tooltipHeight - 10);
                 tooltipContent.style.top = topPos + 'px';
                 tooltipContent.style.left = (rect.left + rect.width / 2) + 'px';
                 tooltipContent.style.bottom = 'auto';
                 tooltipContent.style.right = 'auto';
                 tooltipContent.style.transform = 'translateX(-50%)';
             }
         }
         
         function adjustTooltipPositions() {
             const tooltips = document.querySelectorAll('.stats-tooltip');
             
             tooltips.forEach(tooltip => {
                 const tooltipContent = tooltip.querySelector('.tooltip-content');
                 if (!tooltipContent) return;
                 
                 // Добавляем обработчик для динамического определения позиции при наведении
                 tooltip.addEventListener('mouseenter', function(e) {
                     updateTooltipPosition(this);
                 });
                 
                 // Обновляем позицию при движении мыши, если tooltip видим
                 let isTooltipVisible = false;
                 tooltip.addEventListener('mouseenter', function() {
                     isTooltipVisible = true;
                 });
                 tooltip.addEventListener('mouseleave', function() {
                     isTooltipVisible = false;
                 });
             });
             
             // Обновляем позицию при скролле страницы для видимых tooltip'ов
             let scrollHandler = function() {
                 tooltips.forEach(tooltip => {
                     const tooltipContent = tooltip.querySelector('.tooltip-content');
                     if (tooltipContent) {
                         const style = window.getComputedStyle(tooltipContent);
                         if (style.visibility === 'visible' && parseFloat(style.opacity) > 0) {
                             updateTooltipPosition(tooltip);
                         }
                     }
                 });
             };
             window.addEventListener('scroll', scrollHandler, true);
             window.addEventListener('resize', scrollHandler);
         }

        // Проверяем режим администратора
        const urlParams = new URLSearchParams(window.location.search);
        const isAdmin = urlParams.get('admin') === 'true';
        
        // Функция для переключения вкладок
        function switchTab(tabName) {
            console.log('switchTab вызвана с параметром:', tabName);
            // Скрываем все вкладки
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('show', 'active');
            });
            
            // Убираем активность со всех кнопок
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
                link.setAttribute('aria-selected', 'false');
            });
            
            // Показываем нужную вкладку
            const targetPane = document.getElementById(tabName === 'fav' ? 'fav-matches' : 'all-matches');
            const targetTab = document.getElementById(tabName === 'fav' ? 'fav-tab' : 'all-tab');
            
            console.log('targetPane:', targetPane, 'targetTab:', targetTab);
            
            if (targetPane && targetTab) {
                targetPane.classList.add('show', 'active');
                targetTab.classList.add('active');
                targetTab.setAttribute('aria-selected', 'true');
                console.log('Вкладка переключена успешно');
            } else {
                console.error('Не найдены элементы для переключения вкладки');
            }
        }
        
        // Инициализация обработчиков переключения вкладок
        (function initTabs() {
            const favTab = document.getElementById('fav-tab');
            const allTab = document.getElementById('all-tab');
            
            if (favTab && allTab) {
                console.log('Найдены элементы вкладок, добавляем обработчики');
                favTab.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Клик на вкладку "С фаворитом"');
                    switchTab('fav');
                }, true);  // Используем capture для перехвата до Bootstrap
                
                allTab.addEventListener('click', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Клик на вкладку "Все матчи"');
                    switchTab('all');
                }, true);  // Используем capture для перехвата до Bootstrap
            } else {
                console.log('Элементы вкладок не найдены, повторяем через 100ms');
                // Если элементы еще не загружены, пробуем через небольшую задержку
                setTimeout(initTabs, 100);
            }
        })();
        
        // Загружаем матчи при загрузке страницы
        loadMatches();
        
        // Загружаем лимиты только в режиме администратора
        if (isAdmin) {
            loadLimits();
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</body>
</html>

